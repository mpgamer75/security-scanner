#!/bin/bash
set -euo pipefail

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'

VERSION="2.0.1"

display_banner() {
    clear
    echo -e "${RED}"
    cat << "EOF"
    ███████╗███████╗ ██████╗██╗   ██╗██████╗ ██╗████████╗██╗   ██╗
    ██╔════╝██╔════╝██╔════╝██║   ██║██╔══██╗██║╚══██╔══╝╚██╗ ██╔╝
    ███████╗█████╗  ██║     ██║   ██║██████╔╝██║   ██║    ╚████╔╝ 
    ╚════██║██╔══╝  ██║     ██║   ██║██╔══██╗██║   ██║     ╚██╔╝  
    ███████║███████╗╚██████╗╚██████╔╝██║  ██║██║   ██║      ██║   
    ╚══════╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝   ╚═╝      ╚═╝   
                                                                   
    ███████╗ ██████╗ █████╗ ███╗   ██╗███╗   ██╗███████╗██████╗ 
    ██╔════╝██╔════╝██╔══██╗████╗  ██║████╗  ██║██╔════╝██╔══██╗
    ███████╗██║     ███████║██╔██╗ ██║██╔██╗ ██║█████╗  ██████╔╝
    ╚════██║██║     ██╔══██║██║╚██╗██║██║╚██╗██║██╔══╝  ██╔══██╗
    ███████║╚██████╗██║  ██║██║ ╚████║██║ ╚████║███████╗██║  ██║
    ╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝
EOF
    echo -e "${NC}"
    echo -e "${GRAY}════════════════════════════════════════════════════════════════${NC}"
    echo -e "${WHITE}                 Advanced Security Assessment Tool${NC}"
    echo -e "${CYAN}                      Version ${VERSION} | by mpgamer75${NC}"
    echo -e "${GRAY}════════════════════════════════════════════════════════════════${NC}"
}

show_help() {
    cat << "EOF"

USAGE:
    security [OPTIONS]

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information

SCAN TYPES:
    1. OSINT & Information Gathering
       - WHOIS lookups and domain information
       - DNS enumeration (A, MX, NS, TXT records)
       - Email harvesting and social media intelligence
       - Historical data and archived information

    2. Domain & Certificate Analysis
       - SSL/TLS certificate analysis
       - Subdomain discovery and enumeration
       - Domain reputation and security analysis
       - Certificate transparency logs

    3. Network Port Scanning
       - TCP port scanning (fast and comprehensive)
       - UDP port scanning for critical services
       - Service version detection
       - OS fingerprinting and detection

    4. Complete Assessment
       - Full combination of all scan types
       - Comprehensive security evaluation
       - Detailed reporting and analysis

TOOLS USED:
    OSINT: whois, theharvester, dnsenum, dnsrecon
    Domains: subfinder, amass, assetfinder, findomain
    Certificates: openssl, sslscan, sslyze
    Network: nmap, masscan, unicornscan, zmap
    Web: whatweb, wafw00f, nikto, gobuster, dirb
    Vulnerabilities: nuclei, sqlmap, xssstrike

EXAMPLES:
    security                    # Interactive mode
    security --help            # Show this help

NOTES:
    - All scans are saved in timestamped directories
    - Use only on systems you own or have permission to test
    - Some scans require internet connectivity
    - Advanced scans may take significant time

EOF
}

# Variables globales
declare -A running_processes
declare -A completed_processes
OUTDIR=""
TARGET=""
URL=""
DOMAIN=""

install_missing_tool() {
    local tool="$1"
    echo -e "${YELLOW}[INSTALL]${NC} Installing $tool..."
    
    case "$tool" in
        "subfinder")
            if command -v go &> /dev/null; then
                go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
            else
                echo -e "${RED}[ERROR]${NC} Go is required to install $tool"
                return 1
            fi
            ;;
        "nuclei")
            if command -v go &> /dev/null; then
                go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
            else
                echo -e "${RED}[ERROR]${NC} Go is required to install $tool"
                return 1
            fi
            ;;
        "amass")
            if command -v go &> /dev/null; then
                go install -v github.com/OWASP/Amass/v3/...@master
            else
                echo -e "${RED}[ERROR]${NC} Go is required to install $tool"
                return 1
            fi
            ;;
        *)
            if command -v apt &> /dev/null; then
                sudo apt update && sudo apt install -y "$tool"
            elif command -v yum &> /dev/null; then
                sudo yum install -y "$tool"
            elif command -v pacman &> /dev/null; then
                sudo pacman -S --noconfirm "$tool"
            else
                echo -e "${RED}[ERROR]${NC} Cannot install $tool automatically"
                return 1
            fi
            ;;
    esac
    
    if command -v "$tool" &> /dev/null; then
        echo -e "${GREEN}[SUCCESS]${NC} $tool installed successfully"
        return 0
    else
        echo -e "${RED}[ERROR]${NC} Failed to install $tool"
        return 1
    fi
}

download_wordlist() {
    local url="$1"
    local output="$2"
    local use_fallback="$3"
    
    if [ "$use_fallback" = true ]; then
        curl -sSL --connect-timeout 10 --max-time 60 "$url" -o "$output" 2>/dev/null
    else
        curl -sSL --connect-timeout 10 --max-time 60 "$url" | sudo tee "$output" > /dev/null 2>&1
    fi
    
    return $?
}

create_minimal_common() {
    local output="$1"
    local use_fallback="$2"
    
    local content="admin
administrator
index
login
home
about
contact
news
blog
search
images
img
css
js
api
upload
download
backup
config
tmp
temp
files
data
test
admin.php
login.php
index.php
config.php
backup.sql
database
db
phpinfo
info
server-info
server-status
robots.txt
sitemap.xml"
    
    if [ "$use_fallback" = true ]; then
        echo "$content" > "$output"
    else
        echo "$content" | sudo tee "$output" > /dev/null
    fi
}

create_minimal_big() {
    local output="$1"
    local use_fallback="$2"
    
    local content="admin
administration
administrator
api
app
application
apps
archive
archives
backup
backups
bin
blog
cache
cgi-bin
config
configuration
css
data
database
db
demo
dev
development
doc
docs
download
downloads
email
error
errors
example
examples
file
files
forum
ftp
home
html
http
https
image
images
img
include
includes
index
info
install
installation
js
lib
libs
log
logs
mail
media
member
members
news
old
page
pages
php
phpmyadmin
pics
private
public
root
script
scripts
search
secure
security
site
sites
src
stat
static
stats
support
sys
system
temp
template
templates
test
testing
tests
tmp
tools
upload
uploads
user
users
var
web
webmail
www
.htaccess
.git
.svn
administrator/
admin/
login/
wp-admin/
wp-content/
wp-includes/
wp-config.php
readme.txt
license.txt
changelog.txt
version.txt"
    
    if [ "$use_fallback" = true ]; then
        echo "$content" > "$output"
    else
        echo "$content" | sudo tee "$output" > /dev/null
    fi
}

create_minimal_wordlists() {
    local wordlist_dir="$1"
    local use_fallback="$2"
    
    create_minimal_common "$wordlist_dir/common.txt" "$use_fallback"
    create_minimal_big "$wordlist_dir/big.txt" "$use_fallback"
}

install_wordlists() {
    echo -e "${CYAN}[INFO]${NC} Checking wordlists availability..."
    
    local wordlist_dir="/usr/share/wordlists/dirb"
    local fallback_dir="$HOME/.local/share/wordlists/dirb"
    local use_fallback=false
    
    # Vérifier si on peut écrire dans /usr/share/wordlists
    if [ ! -d "$wordlist_dir" ]; then
        if ! sudo mkdir -p "$wordlist_dir" 2>/dev/null; then
            wordlist_dir="$fallback_dir"
            mkdir -p "$wordlist_dir"
            use_fallback=true
            echo -e "${YELLOW}[INFO]${NC} Using local wordlist directory: $wordlist_dir"
        fi
    fi
    
    # Vérifier si les wordlists existent déjà
    if [ -f "$wordlist_dir/common.txt" ] && [ -f "$wordlist_dir/big.txt" ]; then
        # Vérifier si ce sont de vraies wordlists (taille > 1KB)
        local common_size=$(stat -c%s "$wordlist_dir/common.txt" 2>/dev/null || stat -f%z "$wordlist_dir/common.txt" 2>/dev/null || echo "0")
        local big_size=$(stat -c%s "$wordlist_dir/big.txt" 2>/dev/null || stat -f%z "$wordlist_dir/big.txt" 2>/dev/null || echo "0")
        
        if [ "$common_size" -gt 1000 ] && [ "$big_size" -gt 5000 ]; then
            echo -e "${GREEN}[OK]${NC} Wordlists already available"
            return 0
        fi
    fi
    
    echo -e "${YELLOW}[MISSING]${NC} Wordlists not found or incomplete"
    read -rp "Download and install wordlists? [Y/n]: " install_choice
    
    if [[ "$install_choice" =~ ^[Nn] ]]; then
        echo -e "${YELLOW}[WARNING]${NC} Creating minimal wordlists for basic functionality..."
        create_minimal_wordlists "$wordlist_dir" "$use_fallback"
        return 0
    fi
    
    echo -e "${CYAN}[INFO]${NC} Downloading wordlists..."
    
    # Télécharger common.txt
    if download_wordlist "https://raw.githubusercontent.com/v0re/dirb/master/wordlists/common.txt" "$wordlist_dir/common.txt" "$use_fallback"; then
        echo -e "${GREEN}[OK]${NC} Downloaded common.txt"
    else
        echo -e "${YELLOW}[FALLBACK]${NC} Using alternative source for common.txt"
        download_wordlist "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/common.txt" "$wordlist_dir/common.txt" "$use_fallback" || create_minimal_common "$wordlist_dir/common.txt" "$use_fallback"
    fi
    
    # Télécharger big.txt  
    if download_wordlist "https://raw.githubusercontent.com/v0re/dirb/master/wordlists/big.txt" "$wordlist_dir/big.txt" "$use_fallback"; then
        echo -e "${GREEN}[OK]${NC} Downloaded big.txt"
    else
        echo -e "${YELLOW}[FALLBACK]${NC} Using alternative source for big.txt"
        download_wordlist "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/big.txt" "$wordlist_dir/big.txt" "$use_fallback" || create_minimal_big "$wordlist_dir/big.txt" "$use_fallback"
    fi
    
    echo -e "${GREEN}[COMPLETED]${NC} Wordlists installation finished"
}

check_and_install_tools() {
    local scan_type="$1"
    local tools_needed=()
    local need_wordlists=false
    
    case "$scan_type" in
        "osint")
            tools_needed=(whois dig)
            ;;
        "domain")
            tools_needed=(openssl)
            ;;
        "network")
            tools_needed=(nmap)
            ;;
        "complete")
            tools_needed=(whois dig nmap openssl)
            need_wordlists=true
            ;;
    esac
    
    local missing=()
    echo -e "${CYAN}[INFO]${NC} Checking required tools for $scan_type scan..."
    
    for tool in "${tools_needed[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            missing+=("$tool")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${YELLOW}[WARNING]${NC} Missing critical tools: ${missing[*]}"
        read -rp "Install missing tools automatically? [Y/n]: " install_choice
        
        if [[ ! "$install_choice" =~ ^[Nn] ]]; then
            for tool in "${missing[@]}"; do
                install_missing_tool "$tool"
            done
        else
            echo -e "${RED}[ERROR]${NC} Cannot proceed without required tools"
            exit 1
        fi
    fi
    
    # Installer les wordlists si nécessaire
    if [ "$need_wordlists" = true ] || [ "$scan_type" = "complete" ]; then
        install_wordlists
    fi
    
    echo -e "${GREEN}[OK]${NC} All required tools are available"
}

prepare_output() {
    OUTDIR="security_scan_$(date +'%Y%m%d_%H%M%S')"
    mkdir -p "$OUTDIR"/{osint,domains,network,web,reports}
    echo -e "${GREEN}[INFO]${NC} Results directory: ${WHITE}$OUTDIR${NC}"
}

# Fonction améliorée pour exécuter les commandes avec gestion d'erreurs robuste
execute_with_timeout() {
    local name="$1"
    local command="$2"
    local timeout_duration="${3:-300}"
    local output_file="$4"
    
    echo -e "${CYAN}[START]${NC} $name"
    
    # Désactiver temporairement errexit pour cette commande
    set +e
    timeout "$timeout_duration" bash -c "$command" > "$output_file" 2>&1
    local exit_code=$?
    set -e
    
    case $exit_code in
        0)
            echo -e "${GREEN}[DONE]${NC} $name"
            return 0
            ;;
        124)
            echo -e "${YELLOW}[TIMEOUT]${NC} $name (${timeout_duration}s) - continuing with next scan..."
            # Écrire un message dans le fichier de sortie pour indiquer le timeout
            echo "SCAN TIMEOUT AFTER ${timeout_duration} SECONDS" >> "$output_file"
            return 0  # Retourner 0 pour continuer le script
            ;;
        *)
            echo -e "${RED}[ERROR]${NC} $name failed (exit code: $exit_code) - continuing with next scan..."
            # Écrire un message dans le fichier de sortie pour indiquer l'erreur
            echo "SCAN FAILED WITH EXIT CODE $exit_code" >> "$output_file"
            return 0  # Retourner 0 pour continuer le script
            ;;
    esac
}

show_scan_menu() {
    echo -e "\n${YELLOW}Select scan type:${NC}"
    echo -e "${CYAN}1)${NC} OSINT & Information Gathering"
    echo -e "${CYAN}2)${NC} Domain & Certificate Analysis" 
    echo -e "${CYAN}3)${NC} Network Port Scanning"
    echo -e "${CYAN}4)${NC} Complete Assessment (All scans)"
    echo
}

run_osint_scans() {
    local target="$1"
    local domain="$2"
    
    echo -e "\n${RED}[OSINT]${NC} Starting information gathering..."
    
    if [ -n "$domain" ]; then
        execute_with_timeout "WHOIS Lookup" "whois '$domain'" 60 "$OUTDIR/osint/whois.txt"
        
        execute_with_timeout "DNS Enumeration" "
            echo '=== A Records ===' 
            dig +short '$domain' A
            echo -e '\n=== MX Records ==='
            dig +short '$domain' MX
            echo -e '\n=== NS Records ==='
            dig +short '$domain' NS
            echo -e '\n=== TXT Records ==='
            dig +short '$domain' TXT
        " 60 "$OUTDIR/osint/dns_enum.txt"
        
        if command -v dnsenum &> /dev/null; then
            execute_with_timeout "DNS Enumeration (Advanced)" "dnsenum '$domain'" 300 "$OUTDIR/osint/dnsenum.txt"
        fi
        
        if command -v dnsrecon &> /dev/null; then
            execute_with_timeout "DNS Reconnaissance" "dnsrecon -d '$domain' -t std" 300 "$OUTDIR/osint/dnsrecon.txt"
        fi
        
        if command -v theharvester &> /dev/null; then
            execute_with_timeout "Email Harvesting" "theharvester -d '$domain' -l 100 -b google,bing,yahoo" 300 "$OUTDIR/osint/emails.txt"
        fi
    fi
    
    if [ -n "$target" ]; then
        execute_with_timeout "Reverse DNS" "dig +short -x '$target'" 30 "$OUTDIR/osint/reverse_dns.txt"
    fi
    
    echo -e "${GREEN}[COMPLETED]${NC} OSINT scans finished"
}

run_domain_scans() {
    local domain="$1"
    local url="$2"
    
    echo -e "\n${RED}[DOMAINS]${NC} Starting domain and certificate analysis..."
    
    if [ -n "$domain" ]; then
        if command -v subfinder &> /dev/null; then
            execute_with_timeout "Subfinder Discovery" "subfinder -d '$domain' -silent" 300 "$OUTDIR/domains/subdomains_subfinder.txt"
        fi
        
        if command -v amass &> /dev/null; then
            execute_with_timeout "Amass Enumeration" "amass enum -passive -d '$domain'" 600 "$OUTDIR/domains/subdomains_amass.txt"
        fi
        
        if command -v assetfinder &> /dev/null; then
            execute_with_timeout "Assetfinder Discovery" "assetfinder '$domain'" 300 "$OUTDIR/domains/subdomains_assetfinder.txt"
        fi
        
        execute_with_timeout "SSL Certificate Analysis" "echo | openssl s_client -connect '$domain:443' -servername '$domain' 2>/dev/null | openssl x509 -text" 30 "$OUTDIR/domains/ssl_cert.txt"
        
        if command -v sslscan &> /dev/null; then
            execute_with_timeout "SSL Configuration Scan" "sslscan '$domain'" 300 "$OUTDIR/domains/sslscan.txt"
        fi
    fi
    
    if [ -n "$url" ]; then
        if command -v whatweb &> /dev/null; then
            execute_with_timeout "Technology Detection" "whatweb '$url' -v" 300 "$OUTDIR/domains/whatweb.txt"
        fi
        
        if command -v wafw00f &> /dev/null; then
            execute_with_timeout "WAF Detection" "wafw00f '$url'" 60 "$OUTDIR/domains/wafw00f.txt"
        fi
    fi
    
    # Consolider les sous-domaines
    if ls "$OUTDIR/domains"/subdomains_*.txt 1> /dev/null 2>&1; then
        echo -e "${CYAN}[INFO]${NC} Consolidating subdomain results..."
        cat "$OUTDIR/domains"/subdomains_*.txt 2>/dev/null | sort -u > "$OUTDIR/domains/all_subdomains.txt"
    fi
    
    echo -e "${GREEN}[COMPLETED]${NC} Domain scans finished"
}

run_network_scans() {
    local target="$1"
    
    echo -e "\n${RED}[NETWORK]${NC} Starting network port scanning..."
    
    # 1. Scan rapide initial avec Nmap
    execute_with_timeout "Nmap Quick Discovery" "nmap -n -sn '$target'" 30 "$OUTDIR/network/nmap_ping.txt"
    
    # 2. Scan rapide des ports les plus communs
    execute_with_timeout "Nmap Fast Scan" "nmap -n -T5 --top-ports 1000 --min-rate=5000 '$target'" 300 "$OUTDIR/network/nmap_fast.txt"
    
    # 3. Scan complet TCP avec détection de service et scripts
    execute_with_timeout "Nmap Full TCP Scan" "nmap -n -Pn -T4 -p- -sS -sV -sC '$target'" 1800 "$OUTDIR/network/nmap_full.txt"
    
    # 4. Scan avec options agressives mais rapide
    execute_with_timeout "Nmap Aggressive Scan" "nmap -n -Pn -T4 -A --top-ports 1000 '$target'" 600 "$OUTDIR/network/nmap_aggressive.txt"
    
    # 5. Scan UDP des ports critiques
    execute_with_timeout "Nmap UDP Scan" "nmap -n -Pn -T4 --top-ports 100 -sU '$target'" 600 "$OUTDIR/network/nmap_udp.txt"
    
    # 6. Scan de vulnérabilités avec scripts Nmap
    execute_with_timeout "Nmap Vulnerability Scan" "nmap -n -Pn -T4 --script vuln --top-ports 1000 '$target'" 900 "$OUTDIR/network/nmap_vulns.txt"
    
    # 7. Scan stealthier pour éviter la détection
    execute_with_timeout "Nmap Stealth Scan" "nmap -n -Pn -T2 -f -D RND:10 --top-ports 500 '$target'" 900 "$OUTDIR/network/nmap_stealth.txt"
    
    # 8. Masscan si disponible
    if command -v masscan &> /dev/null; then
        execute_with_timeout "Masscan Ultra-Fast" "masscan '$target' -p1-65535 --rate=50000" 300 "$OUTDIR/network/masscan.txt"
    fi
    
    # 9. Unicornscan si disponible
    if command -v unicornscan &> /dev/null; then
        execute_with_timeout "Unicornscan TCP" "unicornscan -mT '$target':1-1000" 300 "$OUTDIR/network/unicornscan_tcp.txt"
    fi
    
    # 10. OS Fingerprinting avec timeout réduit et options robustes
    execute_with_timeout "OS Fingerprinting" "nmap -n -Pn -O --osscan-guess --max-os-tries 2 '$target'" 180 "$OUTDIR/network/nmap_os.txt"
    
    # 11. Scan des services avec bannière
    execute_with_timeout "Service Banner Grab" "nmap -n -Pn -T4 -sV --version-intensity 5 --top-ports 1000 '$target'" 600 "$OUTDIR/network/nmap_services.txt"
    
    # 12. Scan avec techniques d'évasion
    execute_with_timeout "Nmap Evasion Scan" "nmap -n -Pn -T2 -f --mtu 24 --data-length 1337 --top-ports 500 '$target'" 900 "$OUTDIR/network/nmap_evasion.txt"
    
    echo -e "${GREEN}[COMPLETED]${NC} Network scans finished"
}

run_web_scans() {
    local url="$1"
    
    echo -e "\n${RED}[WEB]${NC} Starting web application testing..."
    
    local wordlist_dir="/usr/share/wordlists/dirb"
    local fallback_dir="$HOME/.local/share/wordlists/dirb"
    
    # Déterminer quel répertoire de wordlists utiliser
    if [ -f "$wordlist_dir/common.txt" ]; then
        local common_wordlist="$wordlist_dir/common.txt"
        local big_wordlist="$wordlist_dir/big.txt"
    elif [ -f "$fallback_dir/common.txt" ]; then
        local common_wordlist="$fallback_dir/common.txt"
        local big_wordlist="$fallback_dir/big.txt"
    else
        echo -e "${RED}[ERROR]${NC} No wordlists found. Run complete scan to install them."
        return 1
    fi
    
    if command -v gobuster &> /dev/null; then
        execute_with_timeout "Directory Enumeration (Common)" "gobuster dir -u '$url' -w '$common_wordlist' -t 50 -x php,html,txt,js" 600 "$OUTDIR/web/gobuster_common.txt"
        
        execute_with_timeout "Directory Enumeration (Big)" "gobuster dir -u '$url' -w '$big_wordlist' -t 30 -x php,html,txt" 900 "$OUTDIR/web/gobuster_big.txt"
    fi
    
    if command -v dirb &> /dev/null; then
        execute_with_timeout "Dirb Enumeration" "dirb '$url' '$common_wordlist'" 600 "$OUTDIR/web/dirb.txt"
    fi
    
    if command -v nikto &> /dev/null; then
        execute_with_timeout "Nikto Vulnerability Scan" "nikto -h '$url'" 600 "$OUTDIR/web/nikto.txt"
    fi
    
    if command -v nuclei &> /dev/null; then
        local template_dirs=(
            "$HOME/nuclei-templates"
            "$HOME/.local/share/nuclei-templates"
            "/usr/share/nuclei-templates"
            "$(go env GOPATH)/pkg/mod/github.com/projectdiscovery/nuclei-templates*"
        )
        
        local template_dir=""
        for dir in "${template_dirs[@]}"; do
            if [ -d "$dir" ]; then
                template_dir="$dir"
                break
            fi
        done
        
        if [ -n "$template_dir" ]; then
            execute_with_timeout "Nuclei Templates" "nuclei -u '$url' -t '$template_dir/'" 600 "$OUTDIR/web/nuclei.txt"
        else
            execute_with_timeout "Nuclei Basic" "nuclei -u '$url'" 300 "$OUTDIR/web/nuclei.txt"
        fi
    fi
    
    if command -v sqlmap &> /dev/null; then
        mkdir -p "$OUTDIR/web/sqlmap"
        execute_with_timeout "SQL Injection Testing" "sqlmap -u '$url' --batch --level=2 --risk=1 --output-dir='$OUTDIR/web/sqlmap'" 600 "$OUTDIR/web/sqlmap.log"
    fi
    
    echo -e "${GREEN}[COMPLETED]${NC} Web scans finished"
}

generate_clean_report() {
    local report_file="$OUTDIR/reports/executive_summary.txt"
    
    echo -e "${CYAN}[INFO]${NC} Generating executive summary report..."
    
    {
        echo "╔══════════════════════════════════════════════════════════════════════════════╗"
        echo "║                            SECURITY ASSESSMENT REPORT                       ║"
        echo "╚══════════════════════════════════════════════════════════════════════════════╝"
        echo
        echo "┌─ TARGET INFORMATION ─────────────────────────────────────────────────────────┐"
        echo "│  IP Address: $TARGET"
        [ -n "$URL" ] && echo "│  URL: $URL"
        [ -n "$DOMAIN" ] && echo "│  Domain: $DOMAIN"
        echo "│  Scan Date: $(date)"
        echo "│  Tool Version: Security Scanner $VERSION"
        echo "└──────────────────────────────────────────────────────────────────────────────┘"
        echo
        echo "┌─ SCAN RESULTS DIRECTORY ─────────────────────────────────────────────────────┐"
        echo "│  Location: $OUTDIR"
        echo "└──────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        # Analyse des résultats OSINT
        if [ -d "$OUTDIR/osint" ] && [ "$(ls -A "$OUTDIR/osint" 2>/dev/null)" ]; then
            echo "┌─ OSINT & INFORMATION GATHERING ──────────────────────────────────────────────┐"
            for f in "$OUTDIR/osint"/*; do
                if [ -f "$f" ]; then
                    local filename=$(basename "$f")
                    local filesize=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo "0")
                    printf "│  %-30s [%s bytes]\n" "$filename" "$filesize"
                fi
            done
            echo "└──────────────────────────────────────────────────────────────────────────────┘"
            echo
        fi
        
        # Analyse des résultats de domaines
        if [ -d "$OUTDIR/domains" ] && [ "$(ls -A "$OUTDIR/domains" 2>/dev/null)" ]; then
            echo "┌─ DOMAIN & CERTIFICATE ANALYSIS ──────────────────────────────────────────────┐"
            for f in "$OUTDIR/domains"/*; do
                if [ -f "$f" ]; then
                    local filename=$(basename "$f")
                    local filesize=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo "0")
                    printf "│  %-30s [%s bytes]\n" "$filename" "$filesize"
                fi
            done
            
            # Compter les sous-domaines trouvés
            if [ -f "$OUTDIR/domains/all_subdomains.txt" ]; then
                local subdomain_count=$(wc -l < "$OUTDIR/domains/all_subdomains.txt" 2>/dev/null || echo "0")
                echo "│  Total subdomains discovered: $subdomain_count"
            fi
            echo "└──────────────────────────────────────────────────────────────────────────────┘"
            echo
        fi
        
        # Analyse des résultats réseau
        if [ -d "$OUTDIR/network" ] && [ "$(ls -A "$OUTDIR/network" 2>/dev/null)" ]; then
            echo "┌─ NETWORK RECONNAISSANCE ──────────────────────────────────────────────────────┐"
            for f in "$OUTDIR/network"/*; do
                if [ -f "$f" ]; then
                    local filename=$(basename "$f")
                    local filesize=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo "0")
                    printf "│  %-30s [%s bytes]\n" "$filename" "$filesize"
                fi
            done
            
            # Analyser les ports ouverts
            if [ -f "$OUTDIR/network/nmap_fast.txt" ]; then
                local open_ports=$(grep -c "open" "$OUTDIR/network/nmap_fast.txt" 2>/dev/null || echo "0")
                echo "│  Open ports detected: $open_ports"
            fi
            
            # Analyser les services détectés
            if [ -f "$OUTDIR/network/nmap_services.txt" ]; then
                local services_detected=$(grep -c "open" "$OUTDIR/network/nmap_services.txt" 2>/dev/null || echo "0")
                echo "│  Services detected: $services_detected"
            fi
            
            # Vérifier les vulnérabilités trouvées
            if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
                local vulns_found=$(grep -c "VULNERABLE" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null || echo "0")
                echo "│  Potential vulnerabilities: $vulns_found"
            fi
            
            echo "└──────────────────────────────────────────────────────────────────────────────┘"
            echo
        fi
        
        # Analyse des résultats web
        if [ -d "$OUTDIR/web" ] && [ "$(ls -A "$OUTDIR/web" 2>/dev/null)" ]; then
            echo "┌─ WEB APPLICATION TESTING ─────────────────────────────────────────────────────┐"
            for f in "$OUTDIR/web"/*; do
                if [ -f "$f" ]; then
                    local filename=$(basename "$f")
                    local filesize=$(stat -c%s "$f" 2>/dev/null || stat -f%z "$f" 2>/dev/null || echo "0")
                    printf "│  %-30s [%s bytes]\n" "$filename" "$filesize"
                elif [ -d "$f" ]; then
                    local dirname=$(basename "$f")
                    printf "│  %-30s [directory]\n" "$dirname"
                fi
            done
            
            # Analyser les répertoires trouvés
            if [ -f "$OUTDIR/web/gobuster_common.txt" ]; then
                local dirs_found=$(wc -l < "$OUTDIR/web/gobuster_common.txt" 2>/dev/null || echo "0")
                echo "│  Web directories found: $dirs_found"
            fi
            echo "└──────────────────────────────────────────────────────────────────────────────┘"
            echo
        fi
        
        echo "┌─ QUICK ANALYSIS ──────────────────────────────────────────────────────────────┐"
        
        # Résumé rapide des découvertes
        if [ -f "$OUTDIR/network/nmap_fast.txt" ]; then
            echo "│  Top Open Ports:"
            grep "open" "$OUTDIR/network/nmap_fast.txt" 2>/dev/null | head -5 | while read line; do
                echo "│    - $line"
            done
        fi
        
        # Afficher les services critiques détectés
        if [ -f "$OUTDIR/network/nmap_services.txt" ]; then
            echo "│  Critical Services:"
            grep -E "(ssh|ftp|telnet|http|https|smtp|pop|imap|ldap|mysql|postgresql|oracle|mssql|vnc|rdp)" "$OUTDIR/network/nmap_services.txt" 2>/dev/null | head -5 | while read line; do
                echo "│    - $line"
            done
        fi
        
        # Afficher les vulnérabilités critiques si trouvées
        if [ -f "$OUTDIR/network/nmap_vulns.txt" ]; then
            echo "│  Security Issues:"
            grep -i "VULNERABLE\|CVE\|CRITICAL\|HIGH" "$OUTDIR/network/nmap_vulns.txt" 2>/dev/null | head -3 | while read line; do
                echo "│    - $line"
            done
        fi
        
        if [ -f "$OUTDIR/domains/all_subdomains.txt" ]; then
            echo "│  Key Subdomains:"
            head -5 "$OUTDIR/domains/all_subdomains.txt" 2>/dev/null | while read line; do
                echo "│    - $line"
            done
        fi
        
        if [ -f "$OUTDIR/web/gobuster_common.txt" ]; then
            echo "│  Important Web Directories:"
            head -5 "$OUTDIR/web/gobuster_common.txt" 2>/dev/null | while read line; do
                echo "│    - $line"
            done
        fi
        
        echo "└──────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        # Statistiques de scan
        echo "┌─ SCAN STATISTICS ─────────────────────────────────────────────────────────────┐"
        local total_files=$(find "$OUTDIR" -type f | wc -l)
        local total_size=$(du -sh "$OUTDIR" 2>/dev/null | cut -f1)
        echo "│  Total files generated: $total_files"
        echo "│  Total data collected: $total_size"
        echo "│  Scan completed: $(date)"
        echo "└──────────────────────────────────────────────────────────────────────────────┘"
        echo
        
        echo "╔══════════════════════════════════════════════════════════════════════════════╗"
        echo "║                    Report generated by Security Scanner v$VERSION                    ║"
        echo "╚══════════════════════════════════════════════════════════════════════════════╝"
        
    } > "$report_file"
    
    echo -e "${GREEN}[REPORT]${NC} Executive summary: ${WHITE}$report_file${NC}"
}

main() {
    # Parse arguments
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "Security Scanner v$VERSION"
            exit 0
            ;;
    esac
    
    display_banner
    
    # Get target information
    echo -e "\n${YELLOW}Target Information:${NC}"
    read -rp "Enter target IP address: " TARGET
    [ -z "$TARGET" ] && { echo -e "${RED}[ERROR]${NC} No IP provided"; exit 1; }
    
    read -rp "Enter target URL (optional): " URL
    read -rp "Enter domain name (optional): " DOMAIN
    
    # Extract domain from URL if not provided
    if [ -n "$URL" ] && [ -z "$DOMAIN" ]; then
        DOMAIN=$(echo "$URL" | sed -E 's|https?://([^/]+).*|\1|')
    fi
    
    show_scan_menu
    read -rp "Select option [1-4]: " SCAN_CHOICE
    
    prepare_output
    
    # Variable pour suivre les interruptions
    local scan_interrupted=false
    
    # Fonction pour gérer les interruptions utilisateur (Ctrl+C)
    handle_interrupt() {
        echo -e "\n${YELLOW}[INFO]${NC} Scan interrupted by user. Generating partial report..."
        scan_interrupted=true
        generate_clean_report
        echo -e "\n${CYAN}[INFO]${NC} Partial results saved in: ${WHITE}$OUTDIR${NC}"
        exit 130
    }
    
    # Configurer le trap pour les interruptions
    trap 'handle_interrupt' SIGINT
    
    # Fonction pour exécuter les scans avec gestion d'interruption
    run_scan_with_interrupt_check() {
        local scan_function="$1"
        shift
        local args=("$@")
        
        if [ "$scan_interrupted" = false ]; then
            if $scan_function "${args[@]}"; then
                return 0
            else
                local exit_code=$?
                if [ $exit_code -eq 130 ]; then
                    scan_interrupted=true
                    return 130
                fi
                return 0
            fi
        fi
        return 0
    }
    
    case "$SCAN_CHOICE" in
        1)
            check_and_install_tools "osint"
            run_scan_with_interrupt_check run_osint_scans "$TARGET" "$DOMAIN"
            ;;
        2)
            check_and_install_tools "domain"
            run_scan_with_interrupt_check run_domain_scans "$DOMAIN" "$URL"
            ;;
        3)
            check_and_install_tools "network"
            run_scan_with_interrupt_check run_network_scans "$TARGET"
            ;;
        4)
            check_and_install_tools "complete"
            run_scan_with_interrupt_check run_osint_scans "$TARGET" "$DOMAIN"
            [ "$scan_interrupted" = false ] && run_scan_with_interrupt_check run_domain_scans "$DOMAIN" "$URL"
            [ "$scan_interrupted" = false ] && run_scan_with_interrupt_check run_network_scans "$TARGET"
            [ "$scan_interrupted" = false ] && [ -n "$URL" ] && run_scan_with_interrupt_check run_web_scans "$URL"
            ;;
        *)
            echo -e "${RED}[ERROR]${NC} Invalid selection"
            exit 1
            ;;
    esac
    
    # Vérifier si le scan a été interrompu
    if [ "$scan_interrupted" = true ]; then
        exit 130
    fi
    
    # Toujours générer le rapport, même en cas de timeouts
    generate_clean_report
    
    echo -e "\n${GREEN}╔══════════════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                              SCAN COMPLETED                                  ║${NC}"
    echo -e "${GREEN}╚══════════════════════════════════════════════════════════════════════════════╝${NC}"
    echo -e "${WHITE}Results saved in:${NC} ${CYAN}$OUTDIR${NC}"
    echo -e "${WHITE}Executive summary:${NC} ${CYAN}$OUTDIR/reports/executive_summary.txt${NC}"
    echo
    echo -e "${CYAN}[TIP]${NC} View results with: ${WHITE}cat $OUTDIR/reports/executive_summary.txt${NC}"
    echo -e "${CYAN}[TIP]${NC} Browse files with: ${WHITE}ls -la $OUTDIR/network/${NC}"
    echo -e "\n${YELLOW}Thank you for using Security Scanner!${NC}"
}

# Execute main function
main "$@"